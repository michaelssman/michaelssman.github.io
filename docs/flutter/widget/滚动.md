# 滚动

一屏幕显示不下，需要上下滚动。

## 滚动条

```dart
body: Scrollbar(
	child: ListView.builder(itemBuilder: itemBuilder),
),
```

## ListView

数据很多的时候，ListView可以动态加载，Column是全部加载。

屏幕能显示多少条数据，只加载显示的。滑出去的回收，新的进来，复用之前的组件。

### 1、数据固定写死的

children是所有的都进来显示。

```dart
ListView(
  children: [
    listViewSection('现金'),
    DiscoverCell(
      imageName: defaultImageName,
      title: '现金',
      onTapCallBack: () {},
    ),
    listViewSection('网络'),
    DiscoverCell(
      title: '微信',
      imageName: defaultImageName,
      onTapCallBack: () {},
    ),
    lineWidget(),
    DiscoverCell(
      title: '支付宝',
      imageName: defaultImageName,
      onTapCallBack: () {},
    ),
  ],
),
```

### 2、数据和UI分离

builder是显示多少加载多少。

```dart
//构造方法
ListView.builder(
  //重要‼️：根据ListView的内容大小来展示，有多少内容，ListView就多大。当item很少占不满一屏，滑动会超出ListView而看不到。
	shrinkWrap: true,
  //itemBuilder是一个回调函数：Function(BuildContext context, int index); 
  //方法返回一个widget 返回每一个item，类似iOS中tableView的cellForRow，鼠标放上去根据提示快速创建createMethod方法
  itemBuilder: _itemForRow, 
  //总共有多少个item
  itemCount: datas.length,
  //cacheExtent: 10, //缓冲区域大小
  //itemExtent: 60,//主轴方向item的高度 最大60 最小60
  scrollDirection: Axis.horizontal, //横向滚动
);

//定义方法，返回一个widget
//dart中不希望外界访问的话加下划线 下划线的内部指文件内部。整个文件都可以访问，其它文件不能访问。
Widget _itemForRow(BuildContext context, int index) {
  return Container(
    ///省略代码
  );
}
```

### 分割线separated

```dart
ListView.separated(
    //分割线
    separatorBuilder: (context, index) {
      return const Divider(thickness: 4,);
    },
    itemBuilder: _itemForRow, //itemBuilder是一个回调，方法返回一个widget 相当于cell
    itemCount: datas.length,
),
```

### 空数据页面

```dart
Container(
  child: _datas.isEmpty
  ? const Center(
    child: Text('loading...'),
  )
  : ListView.builder(
    itemCount: _datas.length,
    itemBuilder: _itemBuilderForRow,
  ),
),
```

### controller

listView滚动的时候需要一个controller属性

点击导航栏文字，跳转到顶部。

```dart
final _controller = ScrollController();

return Scaffold(
  appBar: AppBar(
    title: GestureDetector(
      onTap: (){
        //_controller.jumpTo(0.0);
        //动画
        _controller.animateTo(
          -20.0,
          duration: Duration(seconds: 1),
          curve: Curves.linear,
        );
      },
      child: Text("Demo"),
    ),
  ),
  body: Scrollbar(
    child: ListView.builder(
      itemBuilder: _itemForRow, //itemBuilder是一个回调，方法返回一个widget 相当于cell
      itemCount: datas.length,
      scrollDirection: Axis.horizontal, //横向滚动
    ),
  ),
);
```

现在的位置_controller.offset;

### ListView滚动

item的高度 必须要提前知道位置是多少，根据数据内容计算。

ListView滚动的时候会产生一个事件，这个事件可以被监听到。

```dart
NotificationListener(
    onNotification: (ScrollNotification _event) {
      print(_event);
      return false;
    },
    child: RefreshIndicator(
      //下拉刷新
      onRefresh: () async {
        await Future.delayed(Duration(seconds: 2)); //网络加载数据
        setState(() {});
      },
      child: ListView.builder(
        itemCount: 200,
        controller: _controller,
        itemBuilder: (_, index) {
          return Container(
            color: Colors.blue[index % 9 * 100],
            height: 50,
          );
        },
      ),
    ),
  )
```

### 下拉刷新RefreshIndicator

在Flutter中，`RefreshIndicator`默认的行为是在用户下拉列表时显示指示器，并且在加载完成后指示器消失，列表回到原始位置。如果你想让列表在加载数据时停留在指示器下方，直到数据加载完成，你需要控制列表的滚动位置。

这通常可以通过以下步骤实现：

1. 创建一个`ScrollController`来控制`ListView`的滚动。
2. 在触发刷新操作时，调整滚动位置使得`ListView`保持在指示器下方。
3. 数据加载完成后，再将滚动位置恢复到顶部。

这里有一个简化的例子展示如何实现这个效果：

```dart
class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<int> items = List.generate(20, (i) => i);
  final ScrollController _scrollController = ScrollController();

  Future<void> _handleRefresh() async {
    // 让ListView停留在一定的位置，显示指示器
    _scrollController.jumpTo(50);

    // 模拟网络加载
    await Future.delayed(Duration(seconds: 2));

    // 加载数据
    setState(() {
      items = List.generate(20, (i) => items.length + i);
    });

    // 数据加载完成后，恢复ListView的位置
    _scrollController.animateTo(
      0,
      duration: Duration(milliseconds: 200),
      curve: Curves.easeIn,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Custom Refresh Behavior'),
      ),
      body: RefreshIndicator(
        onRefresh: _handleRefresh,
        color: Colors.white, // 指示器的颜色
        backgroundColor: Colors.blue, // 指示器背景颜色
        displacement: 40.0, // 指示器显示时的偏移量
        child: ListView.builder(
          controller: _scrollController,
          itemCount: items.length,
          itemBuilder: (context, index) {
            return ListTile(
              title: Text('Item ${items[index]}'),
            );
          },
        ),
      ),
    );
  }
}
```

在这个例子中，我们首先使用`jumpTo`方法将`ListView`滚动到一个指定的位置，以便在加载时保持指示器可见。加载完成后，我们使用`animateTo`方法将`ListView`平滑滚动回顶部。

请注意，硬编码的滚动位置（如上例中的`50`）可能不适用于所有情况，因为指示器的大小可能会变化。你可能需要对这个值进行调整，以确保指示器在加载时能够保持可见。此外，这种方法可能会对用户体验产生一些影响，因为它改变了默认的下拉刷新行为。确保这种行为改变是你的应用所需要的，并且对用户来说是直观的。

**`onRefresh`是一个返回`Future<void>`的回调函数**，在用户下拉刷新时被调用。在这个函数中，执行数据加载的异步操作。当操作完成并且`Future`解析后，刷新指示器会消失，UI也会根据新的数据进行更新。

### 滚动方向

scrollDirection

### 滑动删除Dismissible

```dart
ListView.builder(
  itemCount: 200,
  itemBuilder: (_, index) {
    return Dismissible(
      key: UniqueKey(),
      //滑动方向
      direction: DismissDirection.endToStart,
      //一定要有key，要知道哪一个被滑走
      background: Container(
        color: Colors.green,
        alignment: Alignment.centerLeft,
        padding: const EdgeInsets.only(left: 24),
        child: const Icon(
          Icons.phone,
          size: 24,
        ),
      ),
      secondaryBackground: Container(
        color: Colors.black,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 24),
        child: const Icon(
          Icons.sms,
          color: Colors.white,
        ),
      ),
      onDismissed: (direction) {
        //左滑右滑
        print(direction);
        //UI上删除了，业务逻辑的数据上也得删除
        if (direction == DismissDirection.startToEnd) {
          print("phone");
        }
      },
      //删除之后的动作
      onResize: () {
        print("onResize");
        //删除item，页面变化时会调
      },
      confirmDismiss: (direction) async {
        //是否确认删除
        //可以弹出确认弹窗
        return true;
      },
      //默认超过40%就会滑完
      dismissThresholds: const {
        DismissDirection.startToEnd: 0.1,
        DismissDirection.endToStart: 0.99,
      },
      //滑动方向
      direction: DismissDirection.vertical,
      //删除时间
      resizeDuration: const Duration(seconds: 3),
      movementDuration: const Duration(seconds: 3),
      child: Container(
        height: 72,
        color: Colors.blue[index % 9 * 100],
      ),
    );
  },
)
```

### 自定义左滑显示多个按钮

因为`Dismissible`会在动作完成后移除小部件，所以使用`Stack`小部件来叠加**内容**和**滑动背景**。使用`ListTile`配合`GestureDetector`或者`InkWell`来检测滑动手势，并使用`AnimatedContainer`或`AnimatedPositioned`来控制滑动效果。

如果滑动的偏移量超过一定值，固定按钮的位置，否则重置。

```dart
class SwipeList extends StatefulWidget {
  const SwipeList({super.key});

  @override
  _SwipeListState createState() => _SwipeListState();
}

class _SwipeListState extends State<SwipeList> {
  @override
  Widget build(BuildContext context) {
    return HHScaffold(
      ListView.builder(
        itemCount: 20,
        itemBuilder: (context, index) {
          return const ListViewItem();
        },
      ),
    );
  }
}

/// 滑动的item
class ListViewItem extends StatefulWidget {
  const ListViewItem({super.key});

  @override
  State<ListViewItem> createState() => _ListViewItemState();
}

class _ListViewItemState extends State<ListViewItem> {
  double _offset = 0;

  void _slide(double dx) {
    setState(() {
      double newOffset = _offset - dx;
      _offset = newOffset > 150 ? 150 : newOffset;
    });
  }

  void _setEndState() {
    setState(() {
      if (_offset < 75) {
        _offset = 0;
      } else {
        _offset = 150;
      }
    });
  }

  void _reset() {
    setState(() {
      _offset = 0;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black26,
      height: 55,
      child: Stack(
        children: <Widget>[
          Positioned.fill(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: <Widget>[
                IconButton(
                  icon: const Icon(Icons.edit),
                  color: Colors.blue,
                  onPressed: () {
                    // Handle edit
                  },
                ),
                IconButton(
                  icon: const Icon(Icons.delete),
                  color: Colors.red,
                  onPressed: () {
                    // Handle delete
                  },
                ),
              ],
            ),
          ),
          AnimatedPositioned(
            duration: const Duration(milliseconds: 200),
            right: _offset,
            left: -_offset,
            top: 0,
            bottom: 0,
            child: GestureDetector(
              onHorizontalDragUpdate: (details) {
                _slide(details.primaryDelta!);
              },
              onHorizontalDragEnd: (details) {
                _setEndState();
              },
              child: GestureDetector(
                onTap: () {
                  _reset();
                },
                child: Container(
                  color: Colors.white,
                  child: Text('Item'),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

### ListView嵌套ListView

里面的ListView需要设置

```dart
shrinkWrap: true,
physics: const NeverScrollableScrollPhysics(),
```

## GridView

```dart
GridView.builder(
    // gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
    //   crossAxisCount: 4,
    //   childAspectRatio: 16 / 9,
    // ), //横着方向4个
    //设置交叉轴方向最大的尺寸
    gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(
      maxCrossAxisExtent: 120, //最大不超过120
      childAspectRatio: 16 / 9,
      mainAxisSpacing: 2.0, //主轴方向间隙
      crossAxisSpacing: 4.0, //交叉轴方向间隙
    ),
    itemBuilder: (_, index) => Container(
      color: Colors.blue[index % 8 * 100],
    ),
)
```

## ListWheelScrollView

类似iOS的选择器

## ReorderableListView

拖拽移动List顺序