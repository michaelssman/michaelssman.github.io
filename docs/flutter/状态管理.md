# 状态管理

iOS控件有响应，按钮按下去有状态。

flutter增量渲染，没有必要拥有状态。

复杂的设计，一个页面需要改变的东西多。数据的保留。所以需要有状态的widget。底层中渲染逻辑和数据逻辑分开管理。保留的是数据逻辑，不保留的是渲染逻辑，UI每时每刻都在创建新的，但是数据一直保留。

一般整个页面是stl 里面哪个变的是stf

## StatefulWidget

管理数据 state状态。

- 继承StatefulWidget，用于对外提供接口
  - 实现createState方法

- 继承state用来管理状态。	
  - 实现build方法，访问数据，数据在state里面。
  - 通过setState设置/改变数据。

## state

##### `class _state的类名 extends State<哪个StatefulWidget 操纵的哪个>`

定义state类

```
class _DiscoverCellState extends State<DiscoverCell>{
里面复制build方法
如果使用上面的变量的话 使用widget
}
```

##### setState()方法

每次调用setState()方法更改状态都会重新走**build**方法

只要数据改变就手动调用一下，然后会调用build刷新UI，增量渲染。

```
setState(() {
});
```

##### initState()方法

页面进来走一次，创建state的时候走一次，切换页面会重新创建。解决内存，渲染树中会自动处理。

不要把部件创建放这里，这里面放数据，网络请求。

```
void initState(){}
```

##### build(BuildContext context)方法

build方法里面创建部件

```
 Widget build(BuildContext context) {}
```

## cell点击状态

cell非常复杂的时候：

还是把cell的一部分改为有状态的，而不是把整个cell改为有状态的（为了性能考虑）。

## 保持小部件状态

每次切换进入页面都会走initState()，如果不想刷新数据的话，需要混入。

### Mixins混入

目的：给一个类增加功能，是多继承。

1. State类使用with混入AutomaticKeepAliveClientMixin 

2. 实现父类get方法wantKeepAlive

   ```dart
   @override
     // TODO: implement wantKeepAlive
     bool get wantKeepAlive => true;
   ```

3. 在build方法中调用super.build()方法

保持部件状态有一个前提：在widget树中，不会被销毁。
