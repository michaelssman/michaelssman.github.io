# 状态管理

iOS控件有响应，按钮按下去有状态。

flutter增量渲染，没有必要拥有状态。

复杂的设计，一个页面需要改变的东西多。数据的保留。所以需要有状态的widget。底层中渲染逻辑和数据逻辑分开管理。保留的是数据逻辑，不保留的是渲染逻辑，UI每时每刻都在创建新的，但是数据一直保留。

一般整个页面是stl 里面哪个变的是stf。

```dart
class StatefulWidgetDemo extends StatefulWidget {
  const StatefulWidgetDemo({Key? key}) : super(key: key);

  @override
  State<StatefulWidgetDemo> createState() => _StatefulWidgetDemoState();
}

class _StatefulWidgetDemoState extends State<StatefulWidgetDemo> {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
```

## StatefulWidget

管理数据 state状态。

继承StatefulWidget，用于对外提供接口
- 实现createState方法

## state

定义state类：`class _state的类名 extends State<哪个StatefulWidget 操纵的哪个>`

继承state用来管理状态。	

- 实现build方法，访问数据，数据在state里面。
- 通过setState设置/改变数据，会重新走一遍build方法，重新**渲染整个UI**，旧的舍弃掉了，new新的widget
  - 推荐：定义const修饰的widget就不会new。组件拆分的细一些。
    - 例如：cell非常复杂的时候：把cell的一部分改为有状态的，而不是把整个cell改为有状态的（为了性能考虑）。
  - 不推荐：在build方法外面new一个widget，build里面直接用，就不会重新new。context也用不了build方法中的BuildContext。

```dart
class _DiscoverCellState extends State<DiscoverCell>{
里面复制build方法
如果使用上面的变量的话 使用widget
}
```

## 保持小部件状态

每次切换进入页面都会走initState()，如果不想刷新数据的话，需要混入。

### Mixins混入

目的：给一个类增加功能，是多继承。

```dart
class ChatPage extends StatefulWidget {
  const ChatPage({Key? key}) : super(key: key);

  @override
  _ChatPageState createState() => _ChatPageState();
}

class _ChatPageState extends State<ChatPage>
    with AutomaticKeepAliveClientMixin<ChatPage> {
  
  //实现get方法
  @override
  // TODO: implement wantKeepAlive
  bool get wantKeepAlive => true;
  
}
```

1. State类使用`with`混入AutomaticKeepAliveClientMixin。
2. 实现父类get方法wantKeepAlive，返回true。


保持部件状态有一个前提：在widget树中，不会被销毁。
