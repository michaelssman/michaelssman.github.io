# 状态管理

iOS控件有响应，按钮按下去有状态。

flutter增量渲染，没有必要拥有状态。

复杂的设计，一个页面需要改变的东西多。数据的保留。所以需要有状态的widget。底层中渲染逻辑和数据逻辑分开管理。保留的是数据逻辑，不保留的是渲染逻辑，UI每时每刻都在创建新的，但是数据一直保留。

一般整个页面是stl 里面哪个变的是stf。

```dart
class StatefulWidgetDemo extends StatefulWidget {
  const StatefulWidgetDemo({Key? key}) : super(key: key);

  @override
  State<StatefulWidgetDemo> createState() => _StatefulWidgetDemoState();
}

class _StatefulWidgetDemoState extends State<StatefulWidgetDemo> {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
```

## StatefulWidget

管理数据 state状态。

继承StatefulWidget，用于对外提供接口
- 实现createState方法

## state

定义state类：`class _state的类名 extends State<哪个StatefulWidget 操纵的哪个>`

继承state用来管理状态。	

- 实现build方法，访问数据，数据在state里面。
- 通过setState设置/改变数据，会重新走一遍build方法，重新**渲染整个UI**，旧的舍弃掉了，new新的widget
  - 推荐：定义const修饰的widget就不会new。组件拆分的细一些。
    - 例如：cell非常复杂的时候：把cell的一部分改为有状态的，而不是把整个cell改为有状态的（为了性能考虑）。
  - 不推荐：在build方法外面new一个widget，build里面直接用，就不会重新new。context也用不了build方法中的BuildContext。

```dart
class _DiscoverCellState extends State<DiscoverCell>{
里面复制build方法
如果使用上面的变量的话 使用widget
}
```

## 访问和修改外部状态

状态提升，小组件是自己写的，把组件里面的属性提升到父组件，父组件传进来。

如果是别人写的组件就不好实现这种方式。

```dart
class Foo extends StatelessWidget {
  //外面传值，子组件访问外面的值
  final int count;
  //修改外部的值
  //利用回传函数
  // final void Function() onPressed;
  final VoidCallback onPressed;
  //回传函数带参数
  final void Function(int) add;
  const Foo({
    Key? key,
    required this.count,
    required this.onPressed,
    required this.add,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      color: Colors.red.withOpacity(0.5),
      margin: const EdgeInsets.all(16),
      child: Column(
        children: [
          const Center(
            child: FlutterLogo(
              size: 50,
            ),
          ),
          Text('$count'),
          ElevatedButton(
            //修改外部的值
            //利用回传函数
            onPressed: () => onPressed(),
            child: const Text("点击按钮，修改count的值"),
          ),
        ],
      ),
    );
  }
}
```

## 外面的组件控制小组件

需要用到控制器

## Provider

在`pubspec.yaml`引入状态管理的框架`provider`。

管理页面数据，也可以使用数据共享，数据共享是单向传递。

Provider更加方便，各个页面共享数据。

传递数据，通讯。

### 根页面

数据要放在父组件

#### ChangeNotifierProvider

notifyListeners(); //告诉监听者 刷新build

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

//定义一个数据模型 通过混入ChangeNotifier管理监听者（通知模式）
class CountModel with ChangeNotifier {
  int _count = 0;
  //读数据
  int get counter => _count;
  //写数据
  void increment() {
    _count++;
    notifyListeners(); //告诉监听者 刷新build
  }
}

class ProviderDemo extends StatelessWidget {
  const ProviderDemo({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    //通过Provider组建封装数据资源
    return ChangeNotifierProvider.value(
      value: CountModel(), //需要共享的数据
      child: const MaterialApp(
        title: 'ProviderDemo',
        home: ProviderOne(),
      ),
    );
  }
}
```

### 第一个页面

#### 取数据`Provider.of<CountModel>(context)`

```dart
class ProviderOne extends StatelessWidget {
  const ProviderOne({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    //取数据
    final _counter = Provider.of<CountModel>(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('ProviderOne'),
      ),
      body: Center(
        child: Text('第一个页面count:${_counter.counter}'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.of(context).push(MaterialPageRoute(
            builder: (BuildContext context) => const ProviderTwo())),
        child: const Icon(Icons.next_plan),
      ),
    );
  }
}
```

### 第二个页面

性能优化：最小颗粒度的渲染刷新UI。使用`Consumer`。

Consumer包括：

- key
- builder 
- child

```dart
//第二个页面
class ProviderTwo extends StatelessWidget {
  const ProviderTwo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    // //取数据 -- 不再统一的取数据
    // final _counter = Provider.of<CountModel>(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('ProviderTwo'),
      ),
      body: Center(
        //哪里用数据，就在哪里取数据
        child: Consumer<CountModel>(
          builder: (context, CountModel counter, _) =>
              Text('第二个页面count:${counter.counter}'),
        ),
      ),
      floatingActionButton: Consumer(
        child: const MyIcon(), //通过child隔离开，数据变的时候，child不需要重新渲染
        builder: (context, CountModel counter, child) => FloatingActionButton(
          onPressed: counter.increment,
          child: child,
        ),
      ),
    );
  }
}

//自定义icon
class MyIcon extends StatelessWidget {
  const MyIcon({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    print('MyIcon build');
    return const Icon(Icons.add);
  }
}
```

## 保持小部件状态

每次切换进入页面都会走initState()，如果不想刷新数据的话，需要混入。

### Mixins混入

目的：给一个类增加功能，是多继承。

```dart
class ChatPage extends StatefulWidget {
  const ChatPage({Key? key}) : super(key: key);

  @override
  _ChatPageState createState() => _ChatPageState();
}

class _ChatPageState extends State<ChatPage>
    with AutomaticKeepAliveClientMixin<ChatPage> {
  
  //实现get方法
  @override
  // TODO: implement wantKeepAlive
  bool get wantKeepAlive => true;
  
}
```

1. State类使用`with`混入AutomaticKeepAliveClientMixin。
2. 实现父类get方法wantKeepAlive，返回true。

保持部件状态有一个前提：在widget树中，不会被销毁。

### AutomaticKeepAliveClientMixin

`AutomaticKeepAliveClientMixin`是Flutter框架中的一个mixin，它是用来帮助管理页面状态的。

在Flutter中，当有一个widget（例如列表中的一个项目）离开视图时，它的状态可能会被销毁，以释放内存。然而，有些时候可能希望保持这个widget的状态，即使它离开了视图，以便当它再次出现时，它可以恢复到以前的状态。这就是`AutomaticKeepAliveClientMixin`的用途。

要使用`AutomaticKeepAliveClientMixin`，需要在你的widget中混入它，然后重写`wantKeepAlive`方法，使其返回`true`。这将告诉Flutter你希望保持这个widget的状态。然后，你需要在你的`build`方法中调用`super.build(context)`，以确保`AutomaticKeepAliveClientMixin`可以做它需要做的事情。

这个mixin特别适用于那些加载数据或者有用户交互的widget，例如滚动列表或者输入表单，因为这些widget的状态恢复可能会耗费更多的资源。

这是一个简单的示例：

```dart
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context);  // Do not remove this line, it's needed for AutomaticKeepAliveClientMixin.
    return Container();  // Replace with your own widget.
  }
}
```

在这个示例中，即使`MyWidget`离开了视图，它的状态也会被保持，因此当它再次出现时，它可以恢复到以前的状态。
