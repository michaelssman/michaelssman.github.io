# 多线程

1. Isolate（基础）
2. compute（对Isolate基础上的封装）

## Isolate

Isolate更像一个进程，有独立的内存空间，每个进程之间的数据是独立的。不存在资源抢夺的问题。没有同一块数据的问题。

第一个来了和第二个来了是多线程，顺序不是固定的。

```dart
/**
    flutter: 外部代码1
    flutter: 第一个来了10
    flutter: 第二个来了
    flutter: 第二个来了
    flutter: 第一个来了10
    flutter: 第一个来了10
    flutter: 第二个来了
    flutter: 第二个来了
    flutter: 第一个来了10
    flutter: 外部代码2
 */
void IsolateDemo() {
  print('外部代码1'); //主线程
  
  Isolate.spawn(func, 10); //子线程
  Isolate.spawn(func2, 10); //子线程
  Isolate.spawn(func, 10); //子线程
  Isolate.spawn(func2, 10); //子线程
  Isolate.spawn(func, 10); //子线程
  Isolate.spawn(func2, 10); //子线程
  Isolate.spawn(func, 10); //子线程
  Isolate.spawn(func2, 10); //子线程
  
  sleep(Duration(seconds: 2)); //主线程睡眠
  print('外部代码2');
}

func(int count) {
  print('第一个来了$count');
}

func2(int count) {
  print('第二个来了');
}
```

### 数据访问

资源不会被抢夺。a值没有变。

```dart
/**
    flutter: 外部代码1
    flutter: 第一个来了:a = 100
    flutter: a = 10
    flutter: 外部代码2
 */
void IsolateDemo() {
  print('外部代码1'); //主线程

  Isolate.spawn(func, 100); //子线程

  sleep(Duration(seconds: 2)); //主线程睡眠
  print('a = $a'); //a值没有变
  print('外部代码2');
}

int a = 10;

func(int count) {
  a = count;
  print('第一个来了:a = $a');
}
```

#### 子线程想要修改外部数据

通过参数，外部拿到子线程处理完之后的回调。

开辟空间了就需要销毁

完整代码

```dart
/**
    flutter: 外部代码1
    flutter: 第一个来了:a = 10
    flutter: a = 10
    flutter: 外部代码2
    flutter: 接收到了100
 */
void IsolateDemo() async {
  print('外部代码1'); //主线程
//创建一个port端口
  ReceivePort port = ReceivePort();
  //创建Isolate
  Isolate iso =
      await Isolate.spawn(func, port.sendPort); //子线程。异步 await并不会影响下面的代码执行 只是子线程
  //监听数据的变化
  port.listen((message) {
    a = message;
    print('接收到了$a');//外部就可以拿到a 数据隔离 异步处理完之后再回调
    port.close();//端口关掉
    iso.kill();//iso杀掉
  });

  sleep(Duration(seconds: 2)); //主线程睡眠
  print('a = $a'); //a值没有变
  print('外部代码2');
}

int a = 10;

func(SendPort send) {
  sleep(Duration(seconds: 1));
  send.send(100);
  print('第一个来了:a = $a');
}
```

## compute

数据没有隔离

```dart
/*
flutter: 外部代码1
flutter: 第二个来了
flutter: 外部代码2
 */
void computeTest() {
  print('外部代码1'); //主线程
  compute(func2, 10);//子线程
  sleep(Duration(seconds: 2)); //主线程睡2秒
  print('外部代码2'); //主线程
}

func2(int count) {
  print('第二个来了');
}
```

compute可以直接接收子线程任务中的变量。

```dart
/*
flutter: 外部代码1
flutter: 第二个来了
flutter: 外部代码2 a = 10000
 */
int a = 10; //全局变量
void computeTest() async {
  print('外部代码1'); //主线程
  a = await compute(func2, 10); //子线程 变量不隔离，await下面的代码会等待
  print('外部代码2 a = $a'); //主线程
}

int func2(int count) {
  sleep(Duration(seconds: 2)); //子线程睡2秒
  print('第二个来了');
  return 10000;
}
```

```dart
/*
flutter: 外部代码1
flutter: 第二个来了
flutter: 外部代码2 b = 10000 a = 10
 */
int a = 10; //全局变量
void computeTest() async {
  print('外部代码1'); //主线程
  int b = await compute(func2, 10); //子线程 变量不隔离，await下面的代码会等待
  print('外部代码2 b = $b a = $a'); //主线程
}

int func2(int count) {
  sleep(Duration(seconds: 2)); //子线程睡2秒
  print('第二个来了');
  return 10000;
}
```

耗时比较严重才用子线程，唤醒的是渲染队列。

compute和Isolate捕获外部变量都是通过传参数。

compute不需要kill，比较简单。Isolate需要kill销毁。

