# 任务（sync 和 async）

## 同步和异步

同步任务不会开启新线程，都是在**当前线程**。

异步任务会在子线程。

同步串行和同步并发，任务执行的方式是一样的，没有开辟新的线程，**所有的任务都是在一条线程里面执行（当前线程）**。

异步串行和异步并发，任务执行的方式是有区别的，**异步串行会开辟一条新的线程，队列中所有任务按照添加的顺序一个一个执行**，**异步并发会开辟多条线程**，至于具体开辟多少条线程，是由系统决定的。

同步会阻塞当前队列中的任务，异步不会阻塞当前队列中的任务。

##### 列队和任务的组合各种情况分析：

- 同步任务，并发列队

> - 所有任务都是在当前线程中执行，没有开启新的线程（同步方法不具备开启新线程的能力）
> - 同步任务需要等候列队中的任务执行结束，才会执行下一个
> - 并发列队可以开启多线程，并且可以同时执行多个任务，但是同步任务无法创建新线程，所以只有当前一个线程，而且同步任务需要等待列队中前一任务执行结束才能继续执行下面的操作，因此任务只能一个一个顺序执行

- 同步任务，串行列队

> - 和同步任务，并发列队相似
> - 所有任务在当前线程中执行，没有开启新的线程
> - 任务是按照顺序执行的,同步任务，线程需要等待列队中的任务执行完毕，才可以开启新的任务

- 异步任务，并发列队

> - 有几个异步任务就开启了几个新的线程，任务也是同时执行的（异步方法具备开启新线程的能力，可以同时执行多个任务）
> - 异步执行，当前线程不等待，直接开启新的线程来执行，在新线程中执行任务（异步任务，添加异步任务的线程不做等待，可继续执行别的任务）

- 异步任务，串行列队

> - 开启了一条新的线程来执行异步任务（异步任务可以开启新线程，串行列队只能开启一个线程）
> - 线程不会等待任务执行完毕，任务的执行是按照顺序来的，每次只有一个任务被执行，任务一个接一个的执行下去

**同步和异步针对的是线程，影响是否开启新的线程能力。**

**串行和并发针对的是队列，影响任务的执行方式。**

队列只负责调度，没有执行任务能力。

任务依赖线程执行。线程依赖线程池。

队列是排队的情况，

将任务添加到队列，并且指定执行任务的函数

## 主队列

**主队列中的一定是主线程。**

在dispatch_get_main_queue主队列中的一定是主线程，无论是同步函数还是异步函数，只是同步会阻塞，异步不会阻塞。

主队列是串行队列。主队列绑定UI线程。主队列会自动创建，在main函数之前。

- 同步任务，主列队

> - 在主线程中调用会出现死锁，互相等待
> - 死锁原因：当我们在主线程中添加这个列队的时候，添加列队的这个操作本身就是一个任务，我们把它当作任务A，这个任务也被添加到了主线程的列队中。而同步任务，会等待当前列队中前面的任务执行完毕后接着执行，我们把添加到主线程中的列队中的任务称为任务B，这就产生了一个矛盾，任务B要执行需要等任务A执行完毕后才会执行，而任务A执行完毕需要任务B执行结束（因为任务B在任务A中），这就产生了任务互相等待的情况

- 异步任务，主列队

> - 没有开启新线程，所有任务都是在主线程中执行的（虽然异步任务有开启新线程的能力，但因为是在主列队，所以无法开启新线程，所有任务都在主线程中执行）
> - 由于只有一个线程可以使用，所以所有任务都是按顺序一个个执行的，一个完毕，执行下一个

## 同一个队列中的，不开启新线程

异步函数，有开启新线程的能力，不一定开启新线程

异步函数在同一个队列（包括并发队列），不会开启新线程

```objective-c
dispatch_queue_t queue = dispatch_queue_create("haha", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
  NSLog(@"111 - %@",[NSThread currentThread]);
  dispatch_async(queue, ^{
    NSLog(@"222 - %@",[NSThread currentThread]);
  });
});
```

打印结果：

>   111 - <NSThread: 0x6000015f9840>{number = 37, name = (null)}
>
>   222 - <NSThread: 0x6000015f9840>{number = 37, name = (null)}
