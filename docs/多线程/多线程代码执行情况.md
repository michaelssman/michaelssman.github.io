代码是一行一行执行的 
多线程 代码会同时执行    因为会切换线程。


创建多个线程 每个线程都会运行  和普通的代码的执行顺序不同 普通的代码是一行一行执行

线程同步 加锁 解锁 

## 线程调度

当 cpu 数量大于等于线程数量，这个时候是真正并发，可以多个线程同时执行计算。

当 cpu 数量小于线程数量，总有一个 cpu 会运行多个线程，这时候”并发”就是一种模拟出来的状态。

操作系统通过不断的切换线程，每个线程执行一小段时间，让多个线程看起来就像在同时运行。这种行为就称为 “线程调度（Thread Schedule）”。

## 线程生命周期

### 线程状态

在线程调度中，线程至少拥有三种状态 

1. 运行(Running)
2. 就绪(Ready)
3. 等待(Waiting)。阻塞Blocked。

处于 Running 的线程拥有的执行时间，称为 时间片 (Time Slice)，时间片用完时，进入 Ready 状态。如果在 Running状态，时间片没有用完，就开始等待某一个事件（通常是 IO 或 同步 ），则进入 Waiting 状态。

如果有线程从 Running 状态离开，调度系统就会选择一个 Ready 的线程进入 Running 状态。而 Waiting 的线程等待的事件完成后，就会进入 Ready 状态。

## 可调度线程池

线程有一个预值，巅峰值。

1. 是否都在有任务

没有达到就可以创建线程。

##### 任务饱和策略：

- AbortPolicy 直接抛出RejectedExecutionExeception异常来阻止系统正常运行 
- CallerRunsPolicy 将任务回退到调用者 
- DisOldestPolicy 丢掉等待最久的任务
- DisCardPolicy 直接丢弃任务

这四种拒绝策略均实现的RejectedExecutionHandler接口

##### 任务执行速度的影响因素

1. cpu调度情况 核数
2. 任务的复杂度
3. 优先级
4. 线程状态

买奶茶 多个窗口

任务复杂度：买奶茶10杯

优先级：VIP优先买

##### 优先级翻转

IO比CPU更容易得到优先级提升，IO比CPU更容易发生等待。

1. IO密集型线程

   频繁等待的线程（容易饿死，线程容易淘汰）

   调度：

   CPU会发挥调度能力，频繁等待，频繁等待的线程会把优先级提升。任务的执行可能性会提升。

2. CPU密集型线程

   很少等待的线程

优先级影响因素：

1. 用户指定
2. 根据等待的频繁度
3. 长期不执行，会被提升优先级