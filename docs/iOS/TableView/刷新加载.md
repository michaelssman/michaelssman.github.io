### 刷新设置：

```
// 设置回调（一旦进入刷新状态就会调用这个refreshingBlock）
self.tableView.mj_header = ({
// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的refresh方法）
        MJRefreshNormalHeader *header = [MJRefreshNormalHeader headerWithRefreshingTarget:self refreshingAction:@selector(refresh)];
            header.stateLabel.hidden = YES;

            // 设置自动切换透明度(在导航栏下面自动隐藏)
            header.automaticallyChangeAlpha = YES;
            // 隐藏时间
            header.lastUpdatedTimeLabel.hidden = YES;
            // 设置刷新控件底部的背景色
           header.backgroundColor = kBackgroundUIColor;
            // 开始刷新，自动刷新
            [header beginRefreshing];

        header;
    });
```
### 上拉加载更多 设置：

```
            // 设置回调（一旦进入刷新状态就会调用这个refreshingBlock）
            self.tableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^{
                [weakSelf fetchMore];
            }];
            self.tableView.mj_footer.backgroundColor = [UIColor whiteColor];
           // 马上进入刷新状态  很少使用
          //[self.tableView.mj_footer beginRefreshing];
```

自动加载更多
不用滑到底部了再手动的向上拉一下，才去加载更多。
再代理方法中实现加载更多的方法即可：
```
#pragma mark - 上拉加载更多
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    
    if (<#正在加载中#> || <#没有更多数据#>) {
        return;
    }
    
    if (scrollView.contentOffset.y > scrollView.contentSize.height - scrollView.frame.size.height - 100) {
        //  [self.tableView.mj_footer beginRefreshing];
        [self fetchMore];
    }
}
```
注：
上面代理方法如果把` [self fetchMore]`改为`[self.tableView.mj_footer beginRefreshing]，会出现自动跳动到底部的问题。
因为调用mj_footer的beginRefreshing方法，自动跳转到了底部。
所以不应该调用mjfrefresh的加载更多，只能是自己调用接口，用一个标识，标识一下是否正在加载，正在加载的时候就不调用加载更多的方法，不是正在加载的时候就调用加载更多的方法。
```
- (void)fetchMore {
    if (_isFetchMore) {
        return;
    }
    _isFetchMore = YES;
    //请求接口加载更多
    //请求结束之后
    [self.tableView reloadData];
    _isFetchMore= NO;
}
```