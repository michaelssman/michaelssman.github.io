
1、For In循环

    for (TestModel *model in tempArray) {
            if ([model.studentName isEqualToString:@"张999"]) {
                NSLog(@"studentName:%@  studenId:%@",model.studentName,model.studenId);
                break;
            }
    }
    这也是最常用的一个方法。如果需要知道数组下标，用普通的For循环比较方便。
2、利用enumerateObjectsUsingBlock进行遍历

    [tempArray enumerateObjectsUsingBlock:^(TestModel *obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if (obj) {
            if ([obj.studentName isEqualToString:@"张999"]) {
                NSLog(@"studentName:%@  studenId:%@",obj.studentName,obj.studenId);
                *stop = YES;//手动停止遍历
            }
        }else{
            NSLog(@"结束了，但没找到");
        }
    }];
    这种遍历方法代码整合度比较高，用enumerateObjectsWithOptions方法，可以对数组进行倒叙和逆序遍历，比较灵活。另外，使用这个方法对字典的遍历比较方便。
3、NSPredicate 谓词查询

    NSPredicate *preicate = [NSPredicate predicateWithFormat:[NSString stringWithFormat:@"studentName == '%@'",@"张999"]];
    NSArray *results = [tempArray filteredArrayUsingPredicate:preicate];
    if(results){
        TestModel *model = results[0];
        NSLog(@"studentName:%@  studenId:%@",model.studentName,model.studenId);
    }else{
        NSLog(@"没找到");
    }
    NSPredicate 有些类似SQLite数据库查询，支持模糊搜索，多条件搜索等功能。但不支持调整遍历顺序（正序还是逆序）。
4、dispatch_apply 遍历

```
dispatch_apply([tempArray count], dispatch_get_global_queue(0, 0), ^(size_t index){//并行
        TestModel *model = [tempArray objectAtIndex:index];
        if ([model.studentName isEqualToString:@"张999"]) {
            NSLog(@"studentName:%@  studenId:%@",model.studentName,model.studenId);
        }
    });
```

该方法利用GCD开启多条线程，并发处理任务，所以执行效率高，但不支持调整遍历顺序。

注：经过毫秒耗时检测，发现在数组个数小于1000，差别不是很明显。但当数组个数较大，ForIN的速度是最快的，其次是GCD。NSPredicate 表现的最慢。enumerateObjectsUsingBlock 表现中等，查询耗时相对稳定。

综上所述，一般正常开发中，大可根据需求选择对应的遍历方法。但如果是大量数据，就要结合需求和性能，选择一个比较合适的方法了。