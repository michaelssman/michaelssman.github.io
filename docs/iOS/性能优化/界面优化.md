# 卡顿监测

## 利用CADisplayLink检测

FPS卡顿检测 屏幕刷新频率。

YYKit。利用CADisplayLink检测，CADisplayLink是一个绑定在垂直同步信号vsync的计时器。1秒调60次。

CADisplayLink绑定在maiRrunloop上，在主runloop上不断的计时。如果小于60就是卡顿了。

#### 方法二

ping

子线程与主线程通信

## 利用runloop检测

runloop有source timer observer事务，Observer用来监听RunLoop状态的。

Observer用来卡顿监测。

runloop监听事务状态

```
/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0),
    kCFRunLoopBeforeTimers = (1UL << 1),
    kCFRunLoopBeforeSources = (1UL << 2),
    kCFRunLoopBeforeWaiting = (1UL << 5),//休眠之前
    kCFRunLoopAfterWaiting = (1UL << 6),//唤醒之前
    kCFRunLoopExit = (1UL << 7),//退出runloop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
```

如果kCFRunLoopBeforeSources  kCFRunLoopAfterWaiting两个时间段的时间太长，则是发生卡顿。

新创建一个子线程 计算主线程卡顿时间。

使用PLCrashReporter获取堆栈信息，然后上传服务器等操作。

# 卡顿解决

### 界面优化

1. 能异步就异步

2. 拆分成小任务

   60帧完成图片或uI绘制，如果没有完成则会卡顿。

### init和initWithFrame

init 会调initWithFrame 和init。调initWithFrame只会调initWithFrame。

#### 预排版

view把vc传的model显示出来，因为数据的原因会导致重刷加载，浪费性能。

**谁的事情谁做**，view是做视图加载。加载完数据，把数据的json放在viewModel中，把数据的行高、是否显示、富文本格式等放在model中，（高度缓存，label，imageView的高度都放在model中）。

请求网络之后，处理数据，model保存frame和其它数据，这些都在子线程中处理。所有的计算的事情都放在了子线程，提前把所有子控件的frame计算好（预排版）。

预计算 layoutModel

请求网络有了数据就可以知道高度，mode数据（frame布局 height 富文本）都可以处理，不需要等到tableView

请求完数据之后，在子线程中处理完数据，计算控件的高度frame等等，然后回到主线程reloaddata

数据不变，则对应的UI也不会变，高度不变，上滑下滑不需要多次计算。

#### 预编码/解码（预渲染）

UIImage是一个模型，不是控件，有很多属性。

二进制流dataBuffer解码iamgeBuffer，帧缓冲区frameBuffer渲染

拿到data之后，子线程去解码。

预解码和向下采样。

#### 按需加载

滑到哪儿加载哪儿

配合占位图和缓存处理。

#### 异步渲染

控件越来越多，图层越来越复杂，渲染难度增加。

##### UIView layer关系

UIView：交互响应事件

layer：负责渲染图层

UIView是layer的代理。

UIView和layer绑定，渲染耗时，把渲染的东西提炼出来，子线程渲染，渲染完毕，会调用layer的方法，layer发消息（displayLayer）给UIview，把layer视图显示。

事务：

1. layout 构建视图
2. displayer 绘制
3. prepare coreAnimation
4. commit 提交事务 发送给reader server

##### bit image事件响应control

