# 内存管理

## 内存布局

1. 栈区stack

   空间比较小，宝贵

   存放：函数，指针，局部变量，参数

2. 堆区heap

   开辟空间的：通过alloc开辟空间的对象

2. 静态区

4. 未初始化数据.bss

5. 已初始化数据.data

5. 代码段.text

栈、静态区 系统处理。我们关心的是堆

## 内存管理方案

对象的管理机制，ARC，MRC，自动释放池管理，小对象管理，线程池，GC 垃圾回收机制。

## tagged pointer 

小对象：指针+值，存在栈区。

NSString NSIndexPath NSNumber NSDate（跟长度也有关系）。

小对象不受retain release影响。非常快。

### NSString

NSString是一个类簇（Class Clusters），最后生成的对象类型，取决于我们调用的初始化方法。不同的对象类型的管理方式不一样（在retainCount上有所体现）

<table> 
  <tr><th>类型</th><th>初始化后的retainCount</th><th>说明</th></tr>
  <tr><td>__NSCFConstantString</td><td>-1</td><td>系统维护，reatin和release不起作用（程序中内容相同的常量字符串只有一个）</td></tr>
  <tr><td>__NSCFString</td><td>1</td><td>与其它OC对象一样维护retainCount</td></tr>
  <tr><td>__NSTaggedPointerString</td><td>-1</td><td>reatin和release不起作用</td></tr>
</table>

---

## ARC&MRC

## 引用计数

Objective-C提供了三种内存管理方式：manual retain-release（MRR，手动管理），automatic reference counting（ARC，自动引用计数），garbage collection（垃圾回收）。iOS不支持垃圾回收；ARC作为苹果新提供的技术，苹果推荐开发者使用ARC技术来管理内存；这篇笔记主要讲的是手动管理。

内存管理的目的是：

1. 不要释放或者覆盖还在使用的内存，这会引起程序崩溃；

2. 释放不再使用的内存，防止内存泄露。iOS程序的内存资源是宝贵的。

MRR手动管理内存也是基于引用计数的，只是需要开发者发消息给某块内存（或者说是对象）来改变这块内存的引用计数以实现内存管理（ARC技术则是编译器代替开发者完成相应的工作）。一块内存如果计数是零，也就是没有使用者（owner），那么objective-C的运行环境会自动回收这块内存。

**objective-C的内存管理遵守下面这个简单的策略：**

注：文档中把引用计数加1的操作称为“拥有”（own，或者take ownership of）某块对象/内存；把引用计数减1的操作称为放弃（relinquish）这块对象/内存。拥有对象时，你可以放心地读写或者返回对象；当对象被所有人放弃时，objective-C的运行环境会回收这个对象。

1. 你拥有你创建的对象

   也就是说创建的对象（使用alloc，new，copy或者mutalbeCopy等方法）的初始引用计数是1。

2. 给对象发送retain消息后，你拥有了这个对象

3. 当你不需要使用该对象时，发送release或者autorelease消息放弃这个对象

4. 不要对你不拥有的对象发送“放弃”的消息

注：简单的赋值不会拥有某个对象。比如：

```objective-c
NSString *name = person.fullName;
```

上面这个赋值操作不会拥有这个对象（这仅仅是个指针赋值操作）；这和C++语言里的某些基于引用计数的类的行为是有区别的。想拥有一个objective-C对象，必须发送“创建”或者retain消息给该对象。

dealloc方法

dealloc方法用来释放这个对象所占的内存(包括成员变量)和其它资源。

**不要使用dealloc方法来管理稀缺资源，比如文件，网络链接等。因为由于bug或者程序意外退出，dealloc方法不能保证一定会被调用。**



Accessor Methods和内存管理

Accessor Methods，也就是对象的property（属性）的getter和setter方法。显然，如果getter返回的对象已经被运行环境回收了，那么这个getter的返回值是毫无意义的。这就需要在setter方法里“拥有”相应的property。

**比如：**

```objective-c
@interface Counter : NSObject
@property (nonatomic, retain) NSNumber *count;

@end

getter方法仅仅返回成员变量就可以：

-(NSNumber *)count {
  return _count;
}

setter方法需要保证对这个成员变量的“拥有”：

-(void)setCount:(NSNumber *)newCount {
  [newCount retain];          //拥有新值
  [_count release];             //放弃老值
  _count = newCount;       //简单赋值
}
```

**引用计数存在isa里面**

retain流程：

1. 是否是taggedPointer
2. 是否是nonpointer 
   1. 是的话操作的是isa位bits
   2. 不是的话操作sideTable散列表
   3. 是否正在释放

### 散列表

sidetable

多张散列表Sidetables，8或64张表。

```c++
struct SideTable {
    spinlock_t slock;//锁
    RefcountMap refcnts;//引用计数表
    weak_table_t weak_table;//弱引用表

    SideTable() {
        memset(&weak_table, 0, sizeof(weak_table));
    }

    ~SideTable() {
        _objc_fatal("Do not delete SideTable.");
    }

    void lock() { slock.lock(); }
    void unlock() { slock.unlock(); }
    void forceReset() { slock.forceReset(); }

    // Address-ordered lock discipline for a pair of side tables.

    template<HaveOld, HaveNew>
    static void lockTwo(SideTable *lock1, SideTable *lock2);
    template<HaveOld, HaveNew>
    static void unlockTwo(SideTable *lock1, SideTable *lock2);
};
```

为什么是Sidetables

Teacher Person等等都集中在一个表里，会有性能的消耗。

多张表的话，如果释放完了可以进行回收这张表。

但是每个对象都开一张表的话，加锁等也会耗费性能。
