# 方法

没有用到的变量名，不需要定义变量名，使用_*代替*

## 异变方法 mutating

**Swift 中 class 和 struct 都能定义方法**。但是有一点区别的是默认情况 下，**值类型属性不能被自身的实例方法修改**。 

通过 `SIL` 来对比一下，不添加 `mutating` 访问和添加 `mutating` 两者有什么本质的区别 

```swift
struct Point {
    var x = 0.0, y = 0.0
  
		func test(){
			let tmp = self.x
    }
  
	  //需要在func前面加mutating
    func moveBy(x deltaX: Double, y deltaY:Double) { 
        //会报错，修改x、y相当于修改self，self是结构体，如果是class就不需要加mutating
        x += deltaX//
        y += deltaY
    }
}

//test
func testMutating() {
    var p = Point()
	  //相当于p.moveBy(x: 20.0, y: 30.0, &p)，把p地址传进去，修改x、y对外部p有影响
    p.moveBy(x: 20.0, y: 30.0)
}
```

```
//没加mutating Point接收的是结构体实例 self值
sil hidden [ossa] @$s4main5PointV4testyyF : $@convention(method) (Point) -> 

debug_value %0 : $Point, let, name "self", argno 1 // id: %1 

//加了mutating的方法 多了一个inout 接收的是一个地址
sil hidden [ossa] @$s4main5PointV6moveBy1x1yySd_SdtF : $@convention(method) (Double, Double, self : @inout Point)

@inout Point 

debug_value_addr %2 : $*Point, var, name "self", argno 3 // id: %5 

//方法是否加mutating，两者区别：
1. 添加inout
2. 取地址和取值
let self = Point //常量 不可修改 取的是值
var self = &Point //可变 &取的是地址
```

SIL 文档的解释 

An @inout parameter is indirect. The address must be of an initialized object.（当前参数类型是间接的，传递的是已经初始化过的**地址**） 

### 异变方法的本质

**对于变异方法, 传入的 `self` 被标记为 `inout` 参数。取地址赋值，无论在` mutating` 方法内部发生什么，都会影响外部依赖类型的一切。** 相当于self地址传入函数内部。

**输入输出参数：**如果我们想函数能够修改一个形式参数的值，而且希望这些改变在函数结束之后依然生效，那么就需要将形式参数定义为`输入输出形式参数` 。在形式参数定义开始的时候在前边添加一个 inout关键字可以定义一个输入输出形式参数 

```swift
var age = 10

//函数的形式参数都是let类型
func modifyage(_ age: Int) {
    age += 1//报错
}
```

要想修改形式参数

```swift
var age = 10

func modifyage(_ age: inout Int) {
    age += 1
}

modifyage(&age) //传地址
print(age)
```

## 方法调度 

OC：objc_msgsend 

我们先来看一下 Swift 中的方法调度 

```swift
class LGTeacher{
    func teach(){
        print("teach")
    }
}

let t = LGTeacher()
 
t.teach()
```

通过汇编查看 一般bl blr是函数调用

teach函数的调用过程：

1. 找到 `Metadata` 
2. 确定函数地址（metadata + 偏移量）
3. 执行函数

函数基于函数表`V-Table`的调度。 

那么`V-Table`是存放在什么地方那？

之前讲到了`Metdata`的数据结构，`Metdata`中有一个东西需要关注`typeDescriptor`，不管是`Class`，`Struct`,` Enum`都有自己的`Descriptor`，就是对类的一个详细描述。

对TargetClassDescriptor结构体还原之后的结果：

```swift
struct TargetClassDescriptor{
    var flags: UInt32
    var parent: UInt32
    var name: Int32//class名称，struct名称，enum名称。
    var accessFunctionPointer: Int32
    var fieldDescriptor: Int32
    var superClassType: Int32
    var metadataNegativeSizeInWords: UInt32
    var metadataPositiveSizeInWords: UInt32
    var numImmediateMembers: UInt32
    var numFields: UInt32
    var fieldOffsetVectorOffset: UInt32
    var Offset: UInt32
    var size: UInt32
    //V-Table 连续的函数表
}
```

## 方法调度方式总结： 

**结构体值类型没有继承关系，静态派发，编译之后静态指针，编译链接之后函数内存地址已经确定，不需要添加到表中记录。**

```swift
class LGTeacher{
  
    //final 子类不能重写，函数是地址调用，不在vtable中。
    final func teach(){
        print("teach")
    }
  
    //dynamic 赋予函数动态性，但调用方式还是vtable
    dynamic func teach1(){
        print("teach1")
    }
		//一般@objc和dynamic配合使用，变成了消息调度机制objc_msgsend，可以method_swizzling 使用runtime的API
    //    @objc dynamic func teach1(){
    //        print("teach1")
    //    }
  
    func teach2(){
        print("teach2")
    }
}

//teach3不在函数表vtable中
extension LGTeacher{
    @_dynamicReplacement(for: teach1)
    //teach3来替代teach1函数。编译器把teach1指向的imp改为了teach3
    func teach3(){
        print("teach3")
    }
}

//在子类LGPartTeacher的vtable中
class LGPartTeacher: LGTeacher {
    override func teach2() {
        print("Part Teach2")
    }
    func teach4(){
        print("teach4")
    }
}	


//test
func testClassFunc() {
    let cs = LGTeacherCS()
    cs.teach1()//teach3
    cs.teach3()//teach3
    
    let pt = LGPartTeacher()
    pt.teach1()//Part Teach1
}
```

<table> 
  <tr><th>类型</th><th>调度方式</th><th>extension扩展</th></tr>
	<tr><td>值类型struct</td> <td>静态派发</td> <td>静态派发（没有合并到函数表）</td></tr>
	<tr><td>类classs</td> <td>函数表派发</td> <td>静态派发</td></tr>
	<tr><td>NSObject子类</td> <td>函数表派发</td> <td>静态派发</td></tr>
</table>


## 影响函数派发方式 

### 1、final

**添加了 final 关键字的函数无法被重写，自己独有的，子类不能重写**，使用静态派发，不会在 vtable 中出现，且对 objc 运行时不可见。 

实际开发过程中属性，方法，类不需要被重载的时候，使用final关键字。

### 2、dynamic

函数均可添加 dynamic 关键字，为非objc类和值类型的函数赋予动态性，但派发方式还是函数表派发。 

### 3、@objc

该关键字可以将Swift函数暴露给Objc运行时，依旧是函数表派发。 

### 4、@objc + dynamic

消息派发的方式。变成了消息调度的机制

## 函数内联 

函数内联是一种**编译器优化技术**，它通过使用方法的内容替换直接调用该方法，从而优化性能。 

内联函数在swift中是一种默认行为。

- 将确保有时内联函数。这是默认行为，我们无需执行任何操作. Swift 编译器可能会自动内联函数作为优化。 
- always - 将确保始终内联函数。通过在函数前添加 @inline(__always) 来实现此行为。
- never - 将确保永远不会内联函数。这可以通过在函数前添加 @inline(never) 来实现。 
- 如果函数很长并且想避免增加代码段大小，请使用@inline(never)。

```swift
//始终内联
@inline(__always) func test_always(){
    print(#function)
}
//不内联
@inline(never) func test_never(){
    print(#function)
}
```

如果对象只在声明的文件中可见，可以用`private`或`fileprivate `进行修饰。编译器会对`private `或 `fileprivate`对象进行检查，确保**方法**没有其他继承关系的情形下，自动打上`final`标记，进而使得对象获得静态派发的特性（fileprivate： 只允许在定义的源文件中访问，private ： 定义的声明中访问） 

```swift
class LGPerson{
    private var sex: Bool
    private func unpdateSex(){
        self.sex = !self.sex
    }
    init(sex innerSex: Bool) {
        self.sex = innerSex
    }
}
```





