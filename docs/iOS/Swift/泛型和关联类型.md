# 泛型和关联类型

## 为什么会有泛型

```swift
// multiNumInt(_:_:) 、 multiNumDouble(_:_:) 函数体是一样的。唯一的区别是它们接收值类型不同（ Int 、 Double ）。 这个时候我们想找到一个可以计算任意类型值的函数怎么办？泛型正是能让我们写出这样函数的语法。

func multiNumInt(_ x: Int, _ y: Int) -> Int{
    return x * y
}
func multiNumDouble(_ x: Double, _ y: Double) -> Double{
    return x * y
}

//泛型的基本写法 ,首先我我们要指定一个占位符 T ,紧挨着写在函数名后面的 一对尖括号(当前我们这个 T 要遵循 FloatingPoint 协议，计算乘积所必须)；其次我们就可以 使用 T 来替换任意定义的函数形式参数
func multiNum<T: FloatingPoint>(_ x: T, _ y: T) -> T{
    return x * y
}
```

### 泛型也可以是一个闭包

闭包的本质是结构体，所以泛型也可以是一个闭包

```swift
        func makeIntcrement() -> (Int) -> Int{
            var  runningTotal = 10
            return {
                runningTotal += $0
                return runningTotal
            }
        }
        func gencr<T>(t: T){
            
        }
        //调用
        gencr(t: makeIntcrement())
```

### 原理探索

```swift
//还原
struct LGTeacherG{
    var age = 10
}
struct TargetMetadata{//所有的类型都是这个结构体
    var kind: Int
}
//泛型 编译器 VWT（值目击表）里面记录了size stride alignment包括内存管理的函数
//值类型来说，copy move 内存拷贝
//引用类型来说，copy 引用计数加1
struct ValueWitnessTable{
    var initializeBufferWithCopyOfBuffer: UnsafeRawPointer
    var destroy: UnsafeRawPointer
    var initializeWithCopy: UnsafeRawPointer
    var assignWithCopy: UnsafeRawPointer
    var initializeWithTake: UnsafeRawPointer
    var assignWithTake: UnsafeRawPointer
    var getEnumTagSinglePayload: UnsafeRawPointer
    var storeEnumTagSinglePayload: UnsafeRawPointer
    var size: Int
    var stride: Int
    var flags: UInt32
    var extraInhabitantCount: UInt32
}

var structType = LGTeacherG.self//获取类型
let ptr = unsafeBitCast(structType as Any.Type, to: UnsafeMutablePointer<TargetMetadata>.self)
let valueWitnessTable = UnsafeRawPointer(ptr).advanced(by: -MemoryLayout<UnsafeRawPointer>.size).assumingMemoryBound(to: UnsafeMutablePointer<ValueWitnessTable>.self).pointee//advanced移动指针位置
//print(valueWitnessTable.pointee.size)//获取LGTeacherG结构体大小
```

## 关联类型associatedtype

作用：给协议中用到的类型定义一个占位名称

```swift
//非泛型版的栈数据结构
struct LGStack{
    private var items = [Int]()
    mutating func push(_ item: Int){
        items.append(item)
    }
    mutating func pop() -> Int?{
        if items.isEmpty { return nil }
        return items.removeLast()
    }
}

//泛型版的栈数据结构
struct LGStack_New<Element>{
    private var items = [Element]()
    mutating func push(_ item: Element){
        items.append(item)
    }
    mutating func pop() -> Element?{
        if items.isEmpty { return nil }
        return items.removeLast()
    }
}
```

### 和栈的数据结构相关都有相同的操作，抽取相同的行为定一个协议

```swift
protocol StackProtocol_old {
    var itemCount: Int{ get }
    mutating func pop() -> Int?
    func index(of index: Int) -> Int
}
```

### Protocol 也上一个泛型

```swift
//上面定义协议的时候需要指明当前类型，那么能不能给 Protocol 也上一个泛型？
//这样一些就会出现一个错误，系统提示 Protocol 不支持泛型参数，需要我们使用关联类型来代替。

// MARK: 关联类型associatedtype 占位类型  类型别名typealias
// 上面的协议支持的数据类型只有Int，如果想要支持任意类型，需要使用关联类型
// 关联类型给协议中用到的类型一个占位符名称，协议定义中的相关类型我们都可以用这个占位符 替代，等到真正实现协议的时候在去确定当前占位符的类型
protocol StackProtocol {
    associatedtype Item//关联类型
    var itemCount: Int{ get }
    mutating func pop() -> Item?
    func index(of index: Int) -> Item
}

struct HHStack: StackProtocol{
    typealias Item = Int//指定Item类型
    private var items = [Item]()
    var itemCount: Int{
        get{
            return items.count
        }
    }
    mutating func push(_ item: Item){
        items.append(item)
    }
    mutating func pop() -> Item?{
        if items.isEmpty { return nil }
        return items.removeLast()
    }
    func index(of index: Int) -> Item {
        return items[index]
    }
}
```

## 类型别名

为已存在类型定义的一个可选择的名字。类似OC中的typedef。

关键字typealias定义一个类型的别名

当你想通过在一个上下文中更合适可具有表达性的名字来引用一个已存在的类型时，别名就非常有用了

```swift
//AudioSample音频采样率
typealias AudioSample = UInt8
let sample: AudioSample = 32
```

```swift
//定义一个闭包的别名
typealias HHBlock = (_ index: Int) -> Void
```

### 关联类型添加约束

```swift
//1、关联类型添加约束
protocol StackProtocol_yueshu {
    associatedtype Item: FixedWidthInteger//给当前的关联类型添加约束，比如我们要求 Item 必须都要遵循 FixWidthInteger
    var itemCount: Int{ get }
    mutating func pop() -> Item?
    func index(of index: Int) -> Item
}
//2、也可以直接在约束中使用协议
protocol EvenProtocol: StackProtocol{
    //在这个协议里， Even 是一个关联类型。
    //Even 拥有两个约束
  	//1. 它必须遵循 EvenProtocol 协议（就是当前定义的协议）
  	//2. 它的 Item 类型必须是和容器里的 Item 类型相同。 Item 的约束是一个 where 分句。
    //where 分句，泛型 Where 分句要求了关联类型必须遵循指定 的协议，或者指定的类型形式参数和关联类型必须相同。泛型 Where 分句以 Where 关键字开 头，后接关联类型的约束或类型和关联类型一致的关系。
    associatedtype Even: EvenProtocol where Even.Item == Item//where限定语句。

    //协议中添加新的方法
    func pushEven(_ item: Int) -> Even
}

extension HHStack: EvenProtocol{
    func pushEven(_ item: Int) -> HHStack {
        var result = HHStack()
        if item % 2 == 0{
            result.push(item)
        }
        return result
    }
}

// MARK: 判断stack是否相等的方法案例
/// T1和T2遵循StackProtocol协议
/// T1.Item和T2.Item类型相同
/// T1类型的Item遵循Equatable协议
func compare<T1: StackProtocol, T2: StackProtocol>(_ stack1: T1, _ stack2: T2)-> Bool where T1.Item == T2.Item, T1.Item: Equatable {
    guard stack1.itemCount == stack2.itemCount else {
        return false
    }
    for i in 0..<stack1.itemCount {
        if stack1.index(of: i) != stack2.index(of: i) {
            return false
        }
    }
    return true
}
```

## 类型擦除

用处：

AnySequence和AnyCollection把Sequence协议Collection协议封装一层。通过抽象中间层，隐藏具体类型。

```swift
// MARK: 泛型的协议
protocol DataFetch {
    associatedtype dataType
    func fetch(completion: ((Result<dataType, Error>) -> Void)?)
}
//请求用户数据
struct User {//用户模型
    let userId: Int
    let name: String
}

struct UserFetch: DataFetch {
    typealias dataType = User//规定类型是User类型的
    func fetch(completion: ((Result<dataType, Error>) -> Void)?) {
        let user = User(userId: 1001, name: "Kody")
        completion?(.success(user))
    }
}
struct VIPFetch: DataFetch {
    typealias dataType = User
    func fetch(completion: ((Result<dataType, Error>) -> Void)?) {
        let user = User(userId: 0001, name: "VIP")
        completion?(.success(user))
    }
}
    
// 通过AnyDataFetch中间层 请求用户数据和VIP数据，减少耦合
/// 这里我们定义了一个中间层结构体 AnyDataFetch ， AnyDataFetch 实现了 DataFetch 的所有方法。
/// 在 AnyDataFetch 的初始化过程中，实现协议的类型会被当做参数传入（依赖注入）
/// 在 AnyDataFetch 实现的具体协议方法 fetch 中，再转发实现协议的抽象类型。
struct AnyDataFetch<T>: DataFetch {//AnyDataFetch中间层，接受一个T具体类型，遵循DataFetch协议实现方法
    typealias DataType = T
    private let _fetch: (((Result<T, Error>) -> Void)?) -> Void
    init<U: DataFetch>(_ fetchable: U) where U.dataType == T {//初始化的时候 把具体类型和协议类型传进来
        _fetch = fetchable.fetch
    }
    func fetch(completion: ((Result<T, Error>) -> Void)?) {
        _fetch(completion)
    }
}
    
    

//测试 模拟请求用户数据
let userFetch = UserFetch()//初始化userData
let anyDataFetch = AnyDataFetch<User>(userFetch)

let vipFetch = VIPFetch()
let vipDataFetch = AnyDataFetch<User>(vipFetch)

func test_fetch() {
    let userData: AnyDataFetch<User>//初始化 指明泛型是User。隐藏了userData具体的UserData类型
    
}
```

