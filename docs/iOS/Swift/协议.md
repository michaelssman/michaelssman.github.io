# 协议与继承 

通过一个协议来描述当前类的共同行为，并通过 `extension` 的方式来对我们的类进行扩展，这样无疑是很棒的 。

```swift
//CustomStringConvertible是debug下的一个协议属性
class LGTeacherP{
    var age = 10
    var name = "Kody"
    func debug(){
        print(".....")
    }
}
class Dog{
    var name = "糯米"
    var type = "白梗"
    func debug(){
        print(".....")
    }
}

extension LGTeacherP: CustomStringConvertible{
    var description: String { get { return "LGTeacher: \(age)\(name)"}}
}
extension Dog: CustomStringConvertible{
    var description: String { get { return "Dog: \(name)\(type)"}}
}

func print(subject: CustomStringConvertible) {
    let string = subject.description
  	print(string)
    //to do...
}
```

这里我们可以稍微的总结一下： 

- class 本质上定义了一个对象是什么 
- protocol 本质上定义了一个对象有哪些（共同）行为 

## 协议的基本语法 

- 协议要求一个属性必须明确是 `get` 或 `get` 和 `set` 

```swift
protocol HHProtocol{
    var age: Int{ get set }
    var name: String{ get }
}
```

这里需要注意的一点是：并不是说当前声明 get 的属性一定是计算属性 

```swift
class HHTeacherP: HHProtocol{
    var age: Int = 18
    var name: String//name可以是存储属性
    init(_ name: String) {
        self.name = name
    }
}
```

- 协议中的异变方法，表示在该方法可以改变其所属的实例，以及该实例的所有属性（用于枚举和结构体），在为类实现该方法的时候不需要写 mutating 关键字。

  枚举和结构体协议中的方法需要mutating，类不需要mutating。

```swift
protocol Togglable {
  mutating func toggle()
}
```

- 类在实现协议中的**初始化器**，必须使用 required 关键字修饰初始化器的实现（类的初始化器前添加 required 修饰符来表明所有该类的子类都必须实现该初始化器） 

  ```swift
  protocol HHClassProtocol {
      init(_ age: Int)
  }
  class HHTe: HHClassProtocol{
      var age = 10
      required init(_ age: Int) {//必须加require关键字
          self.age = age
      }
  }
  ```

- 类专用协议（通过添加 AnyObject 关键字到协议的继承列表，你就可以限制协议只能被类类型采纳） 

```swift
protocol MyProtocol: AnyObject{}
```

- 可选协议：如果我们不想强制让遵循协议的类类型实现，可以使用 optional 作为前缀放在协议的定义。 

```swift
protocol Incrementable{ 
  optional func increment(by: Int) 
}
```

# 协议原理探究 

- 每个遵守了协议的类，都会有自己的PWT，遵守的协议越多，PWT中存储的函数地址就越多 
- PWT的本质是一个指针数组，第一个元素存储TargetProtocolConformanceDescriptor，其后面存储的是函数地址 
- PWT的数量与协议数量一致 
- Existential Container 是编译器生成的一种特殊的数据类型，用于管理遵守了相同协议的协议类型，因为这些类型的内存大小不一致，所以通过当前的 Existential Container 统一管理 
- 对于小容量的数据，直接存储在 Value Buffer 
- 对于大容量的数据，通过堆区分配，存储堆空间的地址 

### `witness-table`协议见证表protocol with table

类遵循了协议，实现了方法，编译器就会为类创建witness-table，记录类实现方法的编码信息。为每一个遵循协议的类创建witness-table。

两个类继承一个协议，两个协议见证表。

类遵循两个协议，PWT有两个。遵循的协议中的方法越多，PWT中的函数就越多。
