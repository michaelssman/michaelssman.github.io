# 协议与继承 

class 本质上定义了一个对象是什么 

protocol 本质上定义了一个对象有哪些（共同）行为 ，并通过 `extension` 的方式来对我们的类进行扩展。

```swift
//CustomStringConvertible是debug下的一个协议属性
class LGTeacherP{
    var age = 10
    var name = "Kody"
    func debug(){
        print(".....")
    }
}
class Dog{
    var name = "糯米"
    var type = "白梗"
    func debug(){
        print(".....")
    }
}

extension LGTeacherP: CustomStringConvertible{
    var description: String { get { return "LGTeacher: \(age)\(name)"}}
}
extension Dog: CustomStringConvertible{
    var description: String { get { return "Dog: \(name)\(type)"}}
}

func print(subject: CustomStringConvertible) {//subject遵循CustomStringConvertible协议
    let string = subject.description
  	print(string)
    //to do...
}

func test() {
    print(subject: LGTeacherP())
}
```

## 协议中定义属性

协议要求属性必须明确是 `get` 或 `get` 和 `set` 

```swift
protocol HHProtocol{
    var age: Int{ get set }
    var name: String{ get }
}

//这里需要注意的一点是：并不是说当前声明 get 的属性一定是计算属性 
class HHTeacherP: HHProtocol{
    var age: Int = 18
    var name: String//name可以是存储属性
    init(_ name: String) {
        self.name = name
    }
}
```

## 协议中的异变方法

表示在该方法可以改变其所属的实例，以及该实例的所有属性（用于枚举和结构体），在为类实现该方法的时候不需要写 mutating 关键字。

枚举和结构体协议中的方法需要mutating，类不需要mutating。

```swift
protocol Togglable {
  mutating func toggle()
}
```

## 协议中定义初始化器

类在实现协议中的**初始化器**必须使用 required 关键字修饰初始化器的实现（类的初始化器前添加 required 修饰符来表明所有该类的子类都必须实现该初始化器） 

```swift
protocol HHClassProtocol {
    init(_ age: Int)
}
class HHTe: HHClassProtocol{
    var age = 10
    required init(_ age: Int) {//必须加require关键字
        self.age = age
    }
}

//final不允许继承，就可以不加require关键字
final class HHTeF: HHClassProtocol{
    var age = 10
    init(_ age: Int) {
        self.age = age
    }
}
```

## 类专用协议

通过添加 AnyObject 关键字到协议的继承列表，就可以限制协议只能被类类型采纳

```swift
protocol MyProtocol: AnyObject{}
```

## 可选协议

如果不想强制让遵循协议的类类型实现，可以使用 optional 作为前缀放在协议的定义。 

```swift
protocol Incrementable{ 
  optional func increment(by: Int) 
}
```

```swift
@objc protocol IncrementableO{
    @objc optional func increment(by: Int)
}
class HHTeaO: IncrementableO{
}
func testO() {
    let t:IncrementableO = HHTeaO()
    t.increment?(by: 10)
}
```

## 协议和继承

```swift
protocol Incrementable{
//    func increment(by: Int)
}
extension Incrementable{
    func increment(by: Int) {
        print("协议extension实现")
    }
}
class HHTea: Incrementable{
    //PWT
    func increment(by: Int) {
        print("HHTea协议实现")
    }
}
class SubHHTea: HHTea{
    //子类没有实现协议方法，没有协议见证表
}

func test2() {
    let t:Incrementable = SubHHTea()
    t.increment(by: 10)//执行的是HHTea的increment方法 如果protocol Incrementable没有定义increment方法，那么执行的是extension Incrementable的increment方法
}
```

## 协议原理探究 

- 每个遵守了协议的类，都会有自己的PWT，遵守的协议越多，PWT中存储的函数地址就越多 
- PWT的本质是一个指针数组，第一个元素存储TargetProtocolConformanceDescriptor，其后面存储的是函数地址 
- PWT的数量与协议数量一致 
- Existential Container 是编译器生成的一种特殊的数据类型，用于管理遵守了相同协议的协议类型，因为这些类型的内存大小不一致，所以通过当前的 Existential Container 统一管理 
- 对于小容量的数据，直接存储在 Value Buffer 
- 对于大容量的数据，通过堆区分配，存储堆空间的地址 

### `witness-table`协议见证表protocol with table

类遵循了协议，实现了方法，编译器就会为类创建witness-table，记录类实现方法的编码信息。为每一个遵循协议的类创建witness-table。

两个类继承一个协议，两个协议见证表。

类遵循两个协议，PWT有两个。遵循的协议中的方法越多，PWT中的函数就越多。
