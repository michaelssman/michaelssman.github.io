# 指针&内存管理

# 为什么说指针不安全

- ⽐如我们在创建⼀个对象的时候，是需要在堆分配内存空间的。但是这个内存空间的声明周期是有限的，也就意味着如果我们使⽤指针指向这块内容空间，如果当前内存空间的⽣命周期啊到了（引⽤计数为0），那么我们当前的指针是不是就变成了未定义的⾏为了（野指针）。 
- 我们创建的内存空间是有边界的，⽐如我们创建⼀个⼤⼩为10的数组，这个时候我们通过指针访问到了 index = 11 的位置，这个时候是不是就越界了，访问了⼀个未知的内存空间。 
- 指针类型与内存的值类型不⼀致，也是不安全的。 

# 指针类型

Swift中的指针分为两类：

typed pointer 数据类型指针，指定数据**类型指针。**比如int bool 

raw pointer 未指定数据类型的指针(**原⽣指针**)。不知道指针指向的数据类型是什么样的。

基本上我们接触到的指针类型有⼀下⼏种 

<table> 
  <tr><th>Swift</th><th>Object-C</th><th>说明</th></tr>
  <tr><td>unsafePointer< T > 指定数据类型</td><td> const T *</td><td>指针和指针指向的内容都不可变 </td></tr>
  <tr><td>unsafeMutablePointer< T > 指定数据类型</td><td> T *</td><td>指针和指针所指向的内存内容均可变 </td></tr>
  <tr><td>unsafeRawPointer</td><td>const void *</td><td>指针指向的内存区域未定 </td></tr>
  <tr><td>unsafeMutableRawPointer</td><td>void *</td><td>同上</td></tr>
  <tr><td>unsafeBufferPointer< T > （Buffer连续的内存空间）</td><td></td><td></td></tr>
  <tr><td>unsafeMutableBufferPointer< T ></td><td></td><td></td></tr>
  <tr><td>unsafeRawBufferPointer</td><td></td><td></td></tr>
  <tr><td>unsafeMutableRawBufferPointer</td><td></td><td></td></tr>
</table>

Buffer开辟连续的内存空间



# 引用计数

64位信息，strong+unowned

使⽤强引⽤就会造成⼀个问题：循环引⽤。我们来看⼀个经典的循环 

引⽤案例：  

 ```swift
     class LGTeacher{
         var age: Int = 18
         var name: String = "Kody"
         var subject: LGSubject?
         
     }
     class LGSubject{
         var subjectName: String
         var subjectTeacher: LGTeacher
         init(_ subjectName: String, _ subjectTeacher: LGTeacher) {
             self.subjectName = subjectName
             self.subjectTeacher = subjectTeacher
             
         }
     }
     var t = LGTeacher()
     var subject = LGSubject.init("Swift进阶", t)
     t.subject = subject
 ```

上⾯做这段代码是不是就产⽣了两个实例对象之前的强引⽤啊, Swift 提供了两种办法⽤来解决你在使⽤类的属性时所遇到的循环强引⽤问题：弱引⽤（ weak reference ）和⽆主引⽤（ unowned reference )。  

## 弱引⽤ weak

弱引⽤不会对其引⽤的实例保持强引⽤，因⽽不会阻⽌ ARC 释放被引⽤的实例。这个特性阻⽌了引⽤变为循环强引⽤。声明属性或者变量时，在前⾯加上`weak`关键字表明这是⼀个弱引⽤。 

由于弱引⽤不会强保持对实例的引⽤，所以说实例被释放了弱引⽤仍旧引⽤着这个实例也是有可能的。因此，ARC 会在被引⽤的实例被释放是⾃动地设置弱引⽤为 nil 。由于弱引⽤需要允许它们的值为 nil ，它们⼀定得是可选类型。 

## 无主引用 unowned

和弱引⽤类似，⽆主引⽤不会牢牢保持住引⽤的实例。但是不像弱引⽤，总之，⽆主引⽤假定是永远有值的. 

根据苹果的官⽅⽂档的建议。当我们知道两个对象的⽣命周期并不相关，那么我们必须使⽤ weak。相反，⾮强引⽤对象拥有和强引⽤对象同样或者更⻓的⽣命周期的话，则应该使⽤ unowned。

## weak VS unowned

- 如果两个对象的⽣命周期完全和对⽅没关系（其中⼀⽅什么时候赋值为nil，对对⽅都没影响），请⽤ weak（例delegate）。 
- 如果你的代码能确保：其中⼀个对象销毁，另⼀个对象也要跟着销毁，这时候，可以（谨慎）⽤ unowned。 

如果不确定的话，直接使用weak。unowned性能稍好，直接操作位域信息。weak会创建side表，对散列表操作。

weak修饰的是一个可选类型，unowned不是可选类型，假定有值。所以weak安全一点。

# 闭包循环引用

⾸先我们的闭包会⼀般默认捕获我们外部的变量 

```swift
    var age = 18
    
    let closure = {
        age += 1
    }
    
    closure()
    print(age)
```

从打印结果19可以看出来 

闭包内部对变量的修改将会改变外部原始变量的值 

那同样就会有⼀个问题，如果我们在 class 的内部定义⼀个闭包，当前闭包访问属性的过程中，就会对我们当前的实例对象进⾏捕获：

```swift
class HHTeacherC{
    var age = 18
    
    var closure:(()->())?
    
    //通过打印deinit来查看当前对象是否释放
    deinit {
        print("HHTeacher deinit")
    }
}
func closureFunc() {
    let t = HHTeacherC()
    t.closure = {
        t.age += 1
    }
}
```

控制台不输出deinit

如何解决这⾥的循环引⽤

```swift
class HHTeacherC{
    var age = 18
    
    var closure:(()->())?
    
    //通过打印deinit来查看当前对象是否释放
    deinit {
        print("HHTeacher deinit")
    }
}
func closureFunc() {
    let t = HHTeacherC()
    //使用weak
    t.closure = { [weak t] in
        t!.age += 1
    }
    //使用unowned
    t.closure = { [unowned t] in
        t.age += 1
    }
}
```

## 捕获列表

默认情况下，闭包表达式从其周围的范围捕获常量和变量，并强引⽤这些值。您可以使⽤捕获列表来显式控制如何在闭包中捕获值。 

在参数列表之前，捕获列表被写为⽤逗号括起来的表达式列表，并⽤⽅括号括起来。如果使⽤捕获列表，则即使省略参数名称，参数类型和返回类型，也必须使⽤in关键字。 

```swift
    var age = 0
    var height = 0.0
    let closure = { [age] in//age是0 age是let
        print(age)
        print(height)
    }
    
    age = 10
    height = 1.85
    closure()//输出结果为0，1.85
```

创建闭包时，将初始化捕获列表中的条⽬。对于捕获列表中的每个条⽬，将常量初始化为在周围范围内具有相同名称的常量或变量的值。例如，在下⾯的代码中，捕获列表中包含age，但捕获列表中未包含height，这使它们具有不同的⾏为。 

创建闭包时，内部作⽤域中的 age 会⽤外部作⽤域中的 age 的值进⾏初始化，但它们的值未以任何特殊⽅式连接。这意味着更改外部作⽤域中的a的值不会影响内部作⽤域中的age的值，也不会更改封闭内部的值，也不会影响封闭外部的值。相⽐之下，只有⼀个名为height的变量-外部作⽤域中的height -因此，在闭包内部或外部进⾏的更改在两个地⽅均可⻅。

## 强弱共舞

```swift
class HHTeacherC{
    var age = 18
    
    var closure:(()->())?
    
    //通过打印deinit来查看当前对象是否释放
    deinit {
        print("HHTeacher deinit")
    }
}
func closureFunc() {
    let t = HHTeacherC()
    //使用weak
    t.closure = { [weak t] in
        t!.age += 1
        
        // MARK: weak strong dance
        //网络请求时
        if let strongSelf = t{
            print(strongSelf.age)
        }
        //或者 延长t的生命周期的范围
        withExtendedLifetime(t){
            t!.age
        }
    }
    //使用unowned
    t.closure = { [unowned t] in
        t.age += 1
    }
}
```























































