# 闭包

# 函数类型 

函数本身也有自己的类型，它由形式参数类型，返回类型组成。

函数是引用类型

```swift
        func addTwoInts(_ a: Int, _ b: Int) -> Int {
            return a + b
        }

        func addTwoInts(_ a: Double, _ b: Double) -> Double {//同名函数，参数和返回值不同
            return a + b
        }

        var a: (Double, Double) -> Double = addTwoInts//a变量名后面需要加函数类型
        a(10, 20)
        var b = a
        b(20 ,30)
```

# 闭包 

闭包是一个捕获了上下文的常量或者是变量的函数。

```swift
func makeIncrementer() -> () -> Int {//函数 返回值是一个函数（返回值函数 没有参数 返回值是Int）
    var runningTotal = 10
    func incrementer() -> Int {
        runningTotal += 1
        return runningTotal
    }
    return incrementer
}

var a = makeIncrementer()
```

闭包表达式 

```swift
{ (param) -> (returnType) in//in之前定义 参数和返回值类型
	//函数体
}
```

首先按照我们之前的知识积累， OC 中的 Block 其实是一个匿名函数，所以这个表达式要具备 

- 作用域（也就是大括号） 
- 参数和返回值 
- 函数体（in）之后的代码 

## 闭包作为参数

Swift 中的闭包即可以当做变量，也可以当做参数传递。

这里我们来看一下下面的例子熟悉一 下：

```swift
var closure : (Int) -> Int = { (age: Int) in
    return age
}
```

## 闭包作为可选类型

同样的我们也可以把我们的闭包声明一个可选类型： 

```swift
    var closure1 : ((Int) -> Int)?
    closure1 = nil
```

## 闭包作为常量

还可以通过 let 关键字将闭包声明为一个常量(也就意味着一旦赋值之后就不能改变了) 

```swift
    //闭包 常量
    let closure2: (Int) -> Int
    closure2 = {(age: Int) in
        return age
    }
//    closure2 = {(age: Int) in//不能再改变了
//        return age
//    }
```

## 闭包作为参数

同时也可以作为函数的参数 

```swift
    //闭包作为函数参数
    func test(param : () -> Int){
        print(param())
    }
    var age = 10
    test { () -> Int in
        age += 1
        return age
    }
```

## 尾随闭包 

当我们把闭包表达式作为函数的最后一个参数，如果当前的闭包表达式很长，我们可以通过尾随闭包的书写方式来提高代码的可读性。 

```swift
    //尾随闭包
    func test(_ a: Int, _ b: Int, _ c: Int, by: (_ item1: Int, _ item2: Int, _ item3: Int) -> Bool) -> Bool{
        return by(a, b, c)
    }
    //直接传闭包 可读性不好
    test(10, 20, 30, by: {(_ item1: Int, _ item2: Int, _ item3: Int) -> Bool in
        return (item1 + item2 < item3)
    })
    //尾随闭包
//    test(10, 20, 30){
//        
//    }
```

其中闭包表达式是 Swift 语法。使用闭包表达式能更简洁的传达信息。当然闭包表达式的好处有很多： 

- 利用上下文推断参数和返回值类型 
- 单表达式可以隐式返回，既省略 return 关键字 
- 参数名称的简写（比如我们的 $0） 
- 尾随闭包表达式

```swift
    var array = [1, 2, 3]
    array.sort(by: {(item1 : Int, item2: Int) -> Bool in return item1 < item2 })
    array.sort(by: {(item1, item2) -> Bool in return item1 < item2 })//闭包省略参数类型
    array.sort(by: {(item1, item2) in return item1 < item2 })//省略闭包返回值类型
    array.sort{(item1, item2) in item1 < item2 }//单表达式可以隐式返回，既省略 return 关键字
    array.sort{ return $0 < $1 }//参数名称的简写（比如编译器起好名字 $0）
    array.sort{ $0 < $1 }
    array.sort(by: <)
```

## 捕获值

在讲闭包捕获值的时候，我们先来回顾一下 Block 捕获值的情形

## OC Block 和 Swift 闭包相互调用 

我们在OC中定义的Block，在Swift中是如何调用的那？我们来看一下 

## @convention ： 用于修饰函数类型 

- 修饰Swift中的函数类型（调用 C 函数的时候） 
- 调用 OC 方法是，修饰 Swift 函数类型 

# defer 

定义： 

defer {} 里的代码会在当前*代码块*返回的时候执行，无论当前*代码块*是从哪个分支return 的，即使程序抛出错误，也会执行。 

如果多个 defer 语句出现在同一作用域中，则它们出现的顺序与它们执行的顺序相反，也就是先出现的后执行。 

看一个简单的例子：

在使用指针的时候 :

```swift
    let count = 2
    let pointer = UnsafeMutablePointer<Int>.allocate(capacity: count)
    pointer.initialize(repeating: 0, count: count)
    defer {//方法运行结束后调用，管理析构 释放
        pointer.deinitialize(count: count)
        pointer.deallocate()
    }
```

请求网络的时候：

```swift
func netRquest(completion: () -> Void) {
    defer {
        self.isLoading = false
        completion()
    }
    guard error == nil else { return }
}
```

defer要在guard前面

```swift
func test1() {
    guard false else{
        return
    }
    defer {
        print(#function)
    }
}
//test1()//调用test1，如果guard返回了，就不会执行defer，所以要避免这样写
```



# 逃逸闭包 

逃逸闭包的定义：当闭包作为一个实际参数传递给一个函数的时候，并且是在函数返回之后调用，我们就说这个闭包逃逸了。当我们声明一个接受闭包作为形式参数的函数时，你可以在形式参数前写 @escaping 来明确闭包是允许逃逸的。 

- 作为函数的**参数**传递 
- 当前闭包在函数内部**异步**执行或者**被存储** 
- 函数结束，闭包被调用，生命周期结束 
- 不会产生循环引用，函数作用域内释放 
- 编译器更多性能优化 （retain， relsase） 
- 上下文的内存保存再栈上，不是堆上 

注意：可选类型默认是逃逸闭包！！！ 

# 自动闭包 

一种用来把实际参数传递给函数表达式打包的闭包，不接受任何实际参数，当其调用时，返回内部表达式的值。 

好处：用普通表达式代替闭包的写法，语法糖的一种

```swift
    //如果是debug模式，则打印错误信息
    func debugOutPrint(_ condition: Bool , _ message: @autoclosure () -> String){
        if condition {
            print("lg_debug:\(message())")
        }
    }
    
    func dosomething() -> String{
        //耗时操作
        return "Application Error Occured"
    }
    
    //第二个参数 希望既能接受字符串 又能接受一个闭包表达式 所以需要@autoclosure修饰
    debugOutPrint(true, "Application Error Occured")
    debugOutPrint(true, dosomething())
```



















