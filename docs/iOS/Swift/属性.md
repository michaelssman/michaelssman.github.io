# 属性

## 存储属性 

存储属性是一个作为特定类和结构体实例一部分的**常量或变量**。存储属性要么是变量存储属性（由 var 关键字引入）要么是常量存储属性（由 let 关键字引入）。

```swift
class LGTeacher{
    var age: Int
    var name: String
}
```

比如这里的 age 和 name 就是我们所说的存储属性

let 和 var 两者的区别：

- let 用来声明常量，常量的值一旦设置好便不能再被更改； 
- var 用来声明变量，变量的值可以在将来设置为不同的值。 

这里我们来看几个案例： 

```swift
class LGTeacherP{
    let age: Int
    var name: String
    init(age age: Int, name name: String){
        self.age = age
        self.name = name
    }
}

struct LGStudentP{
    let age: Int
    var name: String
}

let t = LGTeacherP(age: 18, name: "Hello")//t不能修改 t存储的实例对象的内存，内存地址不可以改变
t.age = 20
t.name = "Logic"
t = LGTeacherP(age: 30, name: "Kody")

var t1 = LGTeacherP(age: 18, name: "Hello")
t.age = 20
t.name = "Logic"
t = LGTeacherP(age: 30, name: "Kody")

let s = LGStudentP(age: 18, name: "Hello")//s是结构体 值存储 都不能修改
s.age = 25
s.name = "Doman"
s = LGStudentP()

var s1 = LGStudentP(age: 18, name: "Hello")
s.age = 25
s.name = "Doman"
s = LGStudentP()
```

let 和 var 的区别： 

- 从汇编的角度 

- 从 SIL的角度 

  var有set，let没有set

## 计算属性 

存储的属性是最常见的，除了存储属性，类、结构体和枚举也能够定义计算属性，计算属性并不存储值，他们提供 getter 和 setter 来修改和获取值。

存储属性可以是常量或变量

计算属性必须定义为变量。于此同时我们书写计算属性时候必须包含类型，因为编译器需要知道期望返回值是什么。 

```swift
//struct静态调用
struct square{
  //存储属性 实例当中占据内存
    var width: Double
  //计算属性 不占用内存空间 方法
    var area: Double{
        get{
            return width * width
        }
        set{
            self.width = newValue//newValue编译器自动生成的
        }
    }
}
```

计算属性本质是get和set。计算属性不占用内存空间。

## 延迟存储属性 lazy

节省内存空间，不是线程安全的。

- 延迟存储属性的初始值在**其第一次访问使用时才进行计算**。 
- 用关键字 lazy 来标识一个延迟存储属性 

```swift
// MARK: 延迟存储属性lazy
class Subject{
  lazy var age: Int = 18//必须有初始值，即使改成Optional也不行。
}
//test
var sb = Subject()
print(sb.age)
```


这里我们来打印一下使用`lazy` 和不使用`lazy`的时候，当前对象的大小有什么变化？
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919530284-d6cc2f21-cd8c-4dec-9671-0ee17603eeb3.jpeg#height=1170&id=IFhGj&originHeight=1170&originWidth=1762&originalType=binary&status=done&style=none&width=1762)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919537846-eaf16533-a066-4bee-8d5e-086da116792c.jpeg#height=1254&id=MjAhS&originHeight=1254&originWidth=1806&originalType=binary&status=done&style=none&width=1806)


为什么这里会有 8 字节的差距？我们通过`SIL`来查看一下：
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919534372-5ca28e0d-dc25-431d-be71-c63a38cebe40.jpeg#height=402&id=oJqN8&originHeight=402&originWidth=2044&originalType=binary&status=done&style=none&width=2044)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919530099-13afac29-799b-4994-b8fa-1b98a6957e6f.jpeg#height=458&id=X24n6&originHeight=458&originWidth=2100&originalType=binary&status=done&style=none&width=2100)


当我们第一访问他的时候发生了什么事情？
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919534438-1b58bae8-50db-4599-baa3-c94e7d767dc9.jpeg#height=786&id=EVXNy&originHeight=786&originWidth=1190&originalType=binary&status=done&style=none&width=1190)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919530484-87628847-cb07-47a8-a7b5-9fe89addad14.jpeg#height=896&id=VkeBh&originHeight=896&originWidth=2046&originalType=binary&status=done&style=none&width=2046)
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919538206-f7dd6e4f-e811-4be0-ad1b-bb31d156598a.jpeg#height=1402&id=TgC9K&originHeight=1402&originWidth=2116&originalType=binary&status=done&style=none&width=2116)


在回过头来看我们刚才那两句话，这个时候大家理解清楚了没？同样的，这里其实底层是一个`Optional`，我们可以通过`MemoryLayout`来测量一下需要多少大小？（8字节对齐之后是不是就是32）
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919537673-e30e958a-5736-46ac-93e4-d05928f998d5.jpeg#height=642&id=aMLqW&originHeight=642&originWidth=1668&originalType=binary&status=done&style=none&width=1668)


其次我们在来理解一句话：（体现在PPT上）


如果被标记为 lazy 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。


这个该怎么理解，其实很简单，比如多线程我们是不是没办法确定当前代码的执行顺序啊！假设有两个线程同时访问我们当前的`age`变量，这个时候都是第一次访问！
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919540343-15123ffd-68d8-4d2d-b65f-75db9b97d935.jpeg#height=1298&id=uSC5M&originHeight=1298&originWidth=2200&originalType=binary&status=done&style=none&width=2200)

当然这里还有一种写法
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919529568-4b1f1db2-2807-4999-9210-dcdfa2f086cf.jpeg#height=326&id=KKHBy&originHeight=326&originWidth=1218&originalType=binary&status=done&style=none&width=1218)
这个和我们之前直接初始化有什么区别吗？这个能保证我们的变量只初始化一次吗？
![](https://cdn.nlark.com/yuque/0/2020/jpeg/2977480/1606919538160-1cca9aaa-f050-42f6-9d39-98a94228fe30.jpeg#height=1124&id=nCOAP&originHeight=1124&originWidth=2174&originalType=binary&status=done&style=none&width=2174)

## 类型属性 static

也是一个存储属性，static修饰，全局变量

- 类型属性其实就是一个全局变量 
- 类型属性只会被**初始化一次**，可以被修改

## 属性观察者 

属性观察者会观察用来观察属性值的变化，一个 willSet 当属性将被改变调用，即使这个值与原有的值相同。didSet 在属性已经改变之后调用。它们的语法类似于 getter 和 setter。 

```swift
class SubjectName{
	  //存储属性
    var subjectName: String = ""{
        willSet{
            print("subjectName will set value \(newValue)")
        }
        didSet{
            print("subjectName has been changed \(oldValue)")
        }
    }
}
```

这里我们在使用属性观察器的时候，需要注意的一点是在**初始化期间设置属性时不会调用 willSet 和 didSet 观察者**；只有在为完全初始化的实例分配新值时才会调用它们。运行下面这段代码，你会发现当前并不会有任何的输出。 

```swift
class SubjectName{
    
    var subjectName: String = "[unnamed]"{
        willSet{
            print("subjectName will set value \(newValue)")
        }
        didSet{
            print("subjectName has been changed \(oldValue)")
        }
    }
    
    init(subjectName: String) {//初始化的操作，第一次调用不是调get和set，直接把值拷贝到内存地址中。
        self.subjectName = subjectName//不会调用willSet和didSet
    }
    
}

let s = SubjectName(subjectName: "Swift进阶")
```

上面的属性观察者只是对存储属性起作用，如果我们想对计算属性起作用怎么办？很简单，只需将相关代码添加到属性的 setter。

```swift
// MARK: 计算属性添加观察者
class Square{
    var width: Double
    
    var area: Double{
        get{
            return width * width
        }
        set{
            //willSet
            print("area will set value \(newValue)")
            self.width = sqrt(newValue)
            //didSet
            print("area has been changed \(self.width)")
        }
    }
    
    init(width: Double) {
        self.width = width
    }
}
```

## 属性在Macho文件的位置信息 

在第一节课的过程中我们讲到了 Metadata 的元数据结构，我们回顾一下 

```swift
struct Metadata{
    var kind: Int
    var superClass: Any.Type
    var cacheData: (Int, Int)
    var data: Int
    var classFlags: Int32
    var instanceAddressPoint: UInt32
    var instanceSize: UInt32
    var instanceAlignmentMask: UInt16
    var reserved: UInt16
    var classSize: UInt32
    var classAddressPoint: UInt32
    var typeDescriptor: UnsafeMutableRawPointer
    var iVarDestroyer: UnsafeRawPointer
}
```

上一节课讲到方法调度的过程中我们认识了 typeDescriptor ，这里面记录了 V-Table 的相关信息，接下来我们需要认识一下 typeDescriptor 中的 fieldDescripto 

```swift
struct TargetClassDescriptor{
    var flags: UInt32
    var parent: UInt32
    var name: Int32
    var accessFunctionPointer: Int32
    var fieldDescriptor: Int32
    var superClassType: Int32
    var metadataNegativeSizeInWords: UInt32
    var metadataPositiveSizeInWords: UInt32
    var numImmediateMembers: UInt32
    var numFields: UInt32
    var fieldOffsetVectorOffset: UInt32
    var Offset: UInt32
    var size: UInt32
    //V-Table
}
```

fieldDescriptor 记录了当前的属性信息，其中 fieldDescriptor 在源码中的结构如下： 

```swift
struct FieldDescriptor {
    MangledTypeName int32
    Superclass int32
    Kind uint16
    FieldRecordSize uint16
    NumFields uint32
    FieldRecords [FieldRecord]
}
```

其中 NumFields 代表当前有多少个属性， FieldRecords 记录了每个属性的信息，FieldRecords 的结构体如下： 

```swift
struct FieldRecord{
    Flags uint32
    MangledTypeName int32
    FieldName int32
} 
```

