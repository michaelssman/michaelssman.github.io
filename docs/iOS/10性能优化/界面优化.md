# 界面优化

## 卡顿监测

### 利用CADisplayLink检测

FPS卡顿检测 屏幕刷新频率。

YYKit。利用CADisplayLink检测，CADisplayLink是一个绑定在垂直同步信号vsync的计时器。1秒调60次。

CADisplayLink绑定在maiRrunloop上，在主runloop上不断的计时。如果小于60就是卡顿了。

### 方法二

ping

子线程与主线程通信

### 利用runloop检测

runloop有source timer observer事务，Observer用来监听RunLoop状态的。

Observer用来卡顿监测。

runloop监听事务状态

为什么Runloop可以做到卡顿监控：

主线程：

程序中的任务都是在线程中执行，而线程依赖于 RunLoop，并且RunLoop总是在相应的状态下执行任务，执行完成以后会切换到下一个状态，如果在一个状态下执行时间过长导致无法进入下一个状态就可以认为发生了卡顿，所以可以根据主线程 RunLoop 的状态变化检测任务执行时间是否太长。至于多长时间算作卡顿可以依据自己的需要来设置，一般情况下可以设置1秒钟作为阀值。

子线程：

然后，不能在主线程中进行观察任务，因为我们观测的是主线程本身的任务，把观察后的处理任务也加到主线程会使得主线程任务不纯粹，影响检测结果的准确性。所以，我们在子线程中处理检测任务。

如果kCFRunLoopBeforeSources  kCFRunLoopAfterWaiting两个时间段的时间太长，则是发生卡顿。

新创建一个子线程 计算主线程卡顿时间。

使用PLCrashReporter获取堆栈信息，然后上传服务器等操作。

## 卡顿解决

### 界面优化

1. 能异步就异步

2. 拆分成小任务

   60帧完成图片或uI绘制，如果没有完成则会卡顿。

### init和initWithFrame

init 会调initWithFrame 和init。调initWithFrame只会调initWithFrame。

### 预排版

view把vc传的model显示出来，因为数据的原因会导致重刷加载，浪费性能。

**谁的事情谁做**，view是做视图加载。加载完数据，把数据的json放在viewModel中，把数据的行高、是否显示、富文本格式等放在model中，（高度缓存，label，imageView的高度都放在model中）。

请求网络之后，处理数据，model保存frame和其它数据，这些都在子线程中处理。所有的计算的事情都放在了子线程，提前把所有子控件的frame计算好（预排版）。

预计算 layoutModel

请求网络有了数据就可以知道高度，mode数据（frame布局 height 富文本）都可以处理，不需要等到tableView

请求完数据之后，在子线程中处理完数据，计算控件的高度frame等等，然后回到主线程reloaddata

数据不变，则对应的UI也不会变，高度不变，上滑下滑不需要多次计算。

### 预编码/解码（预渲染）

UIImage是一个模型，不是控件，有很多属性。

二进制流dataBuffer解码iamgeBuffer，帧缓冲区frameBuffer渲染

拿到data之后，子线程去解码。

**UIImage优化：预解码和下采样。**

### 按需加载

滑到哪儿加载哪儿

配合占位图和缓存处理。

### 异步渲染

控件越来越多，图层越来越复杂，渲染难度增加。

#### UIView layer关系

UIView：交互响应事件

layer：负责渲染图层

UIView是layer的代理。

UIView和layer绑定，渲染耗时，把渲染的东西提炼出来，子线程渲染，渲染完毕，会调用layer的方法，layer发消息（displayLayer）给UIview，把layer视图显示。

事务：

1. layout 构建视图
2. displayer 绘制
3. prepare coreAnimation
4. commit 提交事务 发送给reader server

#### bit image事件响应control

