# 多线程

## 程序

为完成特定任务、用某种语言编写的一组指令的集合，是一段静态的代码。（程序是静态的）

## 进程

打开程序，放入内存，生成进程。在系统中正在运行的一个应用程序。

在内存中会为每个进程分配不同的内存区域，每个进程之间是独立的。

**进程是操作系统进行资源分配的基本单位**。

## 线程

一个进程（程序）的所有任务都在线程中执行，每个进程至少有一个线程（主线程）。

**线程是操作系统调度执行的基本单位**。

### 多线程

普通的代码执行顺序是一行一行执行。

一个进程可以开启多条线程，多线程并发（同时）执行。

### 主线程

一个iOS程序运行后，默认会开启一条线程，称为主线程

- 处理UI事件（点击事件、滚动事件、拖拽事件等）
- 显示、刷新UI界面

## 并发和并行

单核：搬一会儿砖，劈一会儿柴。切换非常快时就是并发。

多核：两个人一个搬砖，一个劈柴。同一时刻有两个任务执行就是并行。

## CPU

- ALU：计算单元
- Register：寄存器
- PC：执行到哪条指令

## 内存

## 线程状态

在线程调度中，线程至少拥有三种状态 

1. 运行(Running)
2. 就绪(Ready)
3. 等待(Waiting)。阻塞Blocked。

处于 Running 的线程拥有的执行时间，称为 时间片 (Time Slice)，时间片用完时，进入 Ready 状态。

如果在 Running状态，时间片没有用完，就开始等待某一个事件（通常是 IO 或 同步 ），则进入 Waiting 状态。

如果有线程从 Running 状态离开，调度系统就会选择一个 Ready 的线程进入 Running 状态。

而 Waiting 的线程等待的事件完成后，就会进入 Ready 状态。

## 线程调度

当 cpu 数量大于等于线程数量，这个时候是真正并发，可以多个线程同时执行计算。

当 cpu 数量小于线程数量，这时候”并发”就是一种模拟出来的状态。并不是真正的并发，而是至少有一个CPU快速的在多条线程之间调度。

操作系统通过不断的切换线程，每个线程执行一小段时间，让多个线程看起来就像在同时运行。这种行为就称为 “线程调度（Thread Schedule）”。

### 可调度线程池

线程有一个预值，巅峰值。

没有达到就可以创建线程。

### 任务饱和策略：

- AbortPolicy 直接抛出RejectedExecutionExeception异常来阻止系统正常运行 
- CallerRunsPolicy 将任务回退到调用者 
- DisOldestPolicy 丢掉等待最久的任务
- DisCardPolicy 直接丢弃任务

这四种拒绝策略均实现的RejectedExecutionHandler接口

## 任务执行速度的影响因素

1. cpu调度情况 核数
2. 任务的复杂度
3. 优先级
4. 线程状态

例如：买奶茶 多个窗口

任务复杂度：买奶茶10杯

优先级：VIP优先买

### 优先级翻转

IO比CPU更容易得到优先级提升，IO比CPU更容易发生等待。

1. IO密集型线程

   频繁等待的线程（容易饿死，线程容易淘汰）

   CPU会发挥调度能力，频繁等待的线程会把优先级提升。任务的执行可能性会提升。

2. CPU密集型线程

   很少等待的线程

### 优先级影响因素：

1. 用户指定
2. 根据等待的频繁度
3. 长期不执行，会被提升优先级

## 多线程实现方案

### 1、pthread（C）

- 适用于Unix\Linux\Windows等系统
- 跨平台\可移植
- 一套通用的多线程API
- 线程生命周期需程序员管理

### 2、NSThread（OC）

- 使用更加面向对象
- 可直接操作线程对象
- 线程生命周期需程序员管理

### 3、GCD（C）

- 充分利用设备的多核
- 线程生命周期自动管理

### 4、NSOperation（OC）

- 基于GCD（底层是GCD）
- 使用更加面向对象
- 线程生命周期自动管理

## 多线程优缺点

优点

- 能适当提高程序的执行效率
- 能适当提高资源使用率（CPU、内存利用率）

缺点

- 创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间、创建时间90ms。
- 如果开启大量线程，会降低程序性能
- 线程越多，CPU在调度线程上的开销越大
- 程序设计更加复杂：比如线程之间的通信、多线程的数据共享
