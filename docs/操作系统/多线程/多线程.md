# 多线程

## 程序

为完成特定任务、用某种语言编写的一组指令的集合，是一段静态的代码。（程序是静态的）

## 进程

打开程序，放入内存，生成进程。在系统中正在运行的一个应用程序。

在内存中会为每个进程分配不同的内存区域，每个进程之间是独立的。

**进程是操作系统进行资源分配的基本单位**。

进程间通信IPC（Inter Process Communication）需要系统调用，访问会更慢。

## 线程

一个进程（程序）的所有任务都在线程中执行，每个进程至少有一个线程（主线程）。

**线程是操作系统调度执行的基本单位**。

### 多线程

普通的代码执行顺序是一行一行执行。

一个进程可以开启多条线程，多线程并发（同时）执行。

**多线程优缺点**

优点

- 能适当提高程序的执行效率
- 能适当提高资源使用率（CPU、内存利用率）

缺点

- 创建线程是有开销的：内核数据结构（iOS大约1KB）、栈空间、创建时间90ms。
- 如果开启大量线程，会降低程序性能
- 线程越多，CPU在调度线程上的开销越大
- 程序设计更加复杂：比如线程之间的通信、多线程的数据共享

### 主线程

一个程序运行后，默认会开启一条线程，称为主线程

- 处理UI事件（点击事件、滚动事件、拖拽事件等）
- 显示、刷新UI界面

## 并发和并行

### 串行

一个CPU内核按顺序执行每个任务，一个时间点只执行一个任务，任务1完成再执行任务2。

### 并行

多个CPU内核同时执行两个或更多的任务，这样不同的核心可以同时执行不同的任务。并行处理能够显著提高性能。

### 并发

一个CPU内核通过快速切换不同的任务，给人一种多个任务同时进行的感觉，这种技术称为上下文切换。

### 井发＋并行

在一个多核系统中，每个核心可以并行地执行不同的线程，而这些线程之间又可以并发地运行，从而使得整体执行更加高效。

单核：搬一会儿砖，劈一会儿柴。切换非常快时就是并发。

多核：两个人一个搬砖，一个劈柴。同一时刻有两个任务执行就是并行。

## CPU

- ALU：计算单元
- Register：寄存器
- PC：执行到哪条指令

## 内存

## 线程状态

在线程调度中，线程至少拥有三种状态 

1. 运行(Running)
2. 就绪(Ready)
3. 等待(Waiting)。阻塞Blocked。

处于 Running 的线程拥有的执行时间，称为时间片`Time Slice`。

- 时间片用完时，进入 Ready 状态。
- 时间片没有用完，就开始等待某一个事件（通常是IO或同步），则进入 Waiting 状态。
  - 等待的事件完成后，就会进入 Ready 状态。

如果有线程从`Running`状态离开，调度系统就会选择一个`Ready`的线程进入`Running`状态。

## 线程调度

当 cpu 数量大于等于线程数量，这个时候是真正并发，可以多个线程同时执行计算。

当 cpu 数量小于线程数量，这时候”并发”就是一种模拟出来的状态。并不是真正的并发，而是至少有一个CPU快速的在多条线程之间调度。

操作系统通过不断的切换线程，每个线程执行一小段时间，让多个线程看起来就像在同时运行。这种行为就称为 “线程调度（Thread Schedule）”。

### 可调度线程池

线程有一个巅峰值，没有达到就可以创建线程。

**任务饱和策略：**

- AbortPolicy 直接抛出RejectedExecutionExeception异常来阻止系统正常运行 
- CallerRunsPolicy 将任务回退到调用者 
- DisOldestPolicy 丢掉等待最久的任务
- DisCardPolicy 直接丢弃任务

这四种拒绝策略均实现的RejectedExecutionHandler接口

## 任务执行速度的影响因素

1. cpu核数
2. 任务的复杂度
3. 优先级
4. 线程状态

例如：买奶茶 多个窗口

任务复杂度：买奶茶10杯

优先级：VIP优先买

### 优先级翻转

IO比CPU更容易得到优先级提升，IO比CPU更容易发生等待。

1. IO密集型线程

   频繁等待的线程（容易饿死，线程容易淘汰）

   CPU会发挥调度能力，频繁等待的线程会把优先级提升。任务的执行可能性会提升。

2. CPU密集型线程

   很少等待的线程

### 优先级影响因素：

1. 用户指定
2. 根据等待的频繁度
3. 长期不执行，会被提升优先级

## 多线程实现方案

### 1、pthread（C）

- 适用于Unix\Linux\Windows等系统
- 跨平台\可移植
- 线程生命周期需程序员管理

### 2、NSThread（OC）

- 使用更加面向对象
- 线程生命周期需程序员管理

### 3、GCD（C）

- 线程生命周期自动管理

### 4、NSOperation（OC）

- 基于GCD（底层是GCD）
- 使用更加面向对象
- 线程生命周期自动管理

## 为了防止UI渲染被阻塞，可以有哪些办法处理?

- 异步：主要用于单次I/0的开发场景。例如一次网络请求、一次文件读写等操作。
- 多线程：主要用于CPU密集型任务、I/0密集型任务和同步任务等并发场景。
  - CPU密集型任务:占用系统资源处理大量计算能力的任务，需要长时间运行。例如图像处理、视频编码、数据分析等。
  - I/O密集型任务:通常需要频繁地进行磁盘读写、网络通信等操作。
  - 同步并发任务:在多个线程之间协调执行的任务，其目的是确保多个任务按照一定的顺序和规则执行，以达到特定的目的。
