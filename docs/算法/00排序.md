# 排序

- 希尔
- 快速
- 归并

#### 排序中的关键操作

1. 比较
       任意两个数据元素通过比较操作确定先后次序
2. 交换
       数据元素之间需要交换才能到的预期结果

#### 内排序和外排序

1. 内排序
       整个排序过程不需要访问外存便能完成
2. 外排序
       待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成

#### 排序的审判

1. 时间性能
       关键性能差异体现在比较和交换的数量
2. 辅助存储空间
       为完成排序操作需要的额外的存储空间
       必要时可以“空间换时间”
3. 算法的实现复杂性
       过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能

#### 总结

- 排序是数据元素从无序到有序的过程
- 排序具有稳定性，是选择排序算法的因素之一
- 比较和交换是排序的基本操作
- 多关键字排序和单关键字排序无本质区别
- 排序的时间性能是区分排序算法好坏的主要因素

# 希尔排序

> 排序过程：
>
> 先取一个正整数d1<n，把所有相隔d1的记录放一组，组内进行直接插入排序；然后取d2<d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为至
>
> O(n-1.3)
>
> O(nlogn)
>
> 希尔排序是不稳定的



希尔和插入法 差不多

![B174CEED-C45E-40FE-AC46-1C2D23952631](assets/B174CEED-C45E-40FE-AC46-1C2D23952631.png)

希尔排序的gap（间隙）等于1的时候  和 插入法 一样

分组排序  希尔牛逼

![CF1CE663-1594-4366-A7E4-6F19E0BBDDEF](assets/CF1CE663-1594-4366-A7E4-6F19E0BBDDEF.png)


10个数据 
按照冒泡 选择 需要9趟
希尔法  3趟解决。

希尔不稳定  相同的数据 可能顺序改变 但是打破的O（n2）。

希尔算法的平均效率 O(n*1.3)
每次问题规模缩减三分之一，分区同时排序。
如果有20个数据
gap = gap / 3 + 1；

# 快速排序
1. 递归把数据分成两部分
2. 做partition
思想：
快速排序是对冒泡排序的一种改进。它的基本思想是：
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，基准数据排在这两个子序列的中间；
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

![708FC6AA-DF88-4A3A-B117-A90B9F2D528B](assets/708FC6AA-DF88-4A3A-B117-A90B9F2D528B.png)

![2174F66E-FC35-4777-8ADC-213F53283D3C](assets/2174F66E-FC35-4777-8ADC-213F53283D3C.png)

第一次时 low是`0` high是`len（长度） - 1`
两头移动两个指针 high low， 先取第一个元素，第一个元素就为空，空的一端不移动，另一端和取出来的比较。
结果：两个数组 一个比取出的元素大  一个比取出的元素小。

#  归并排序
稳定的  突破O（n2）
牺牲空间

![09600021-203C-4175-8393-20A59942CA5C](assets/09600021-203C-4175-8393-20A59942CA5C.png)

merge 归并
![D237C5FE-0995-4785-94B2-5FE0201C7932](assets/D237C5FE-0995-4785-94B2-5FE0201C7932.png)