# 排序

## 为什么要排序

有很多数据，如果不进行排序的话，操作起来会非常的慢。 

先对数据从小到大进行排序，后续对数据进行操作会比较快。

排序消耗一点时间。

算法先了解原理，再写代码。

## 冒泡排序

冒泡法是相邻两个元素进行比较

冒泡有两种
一种是浮出水面  从前到后
一种是沉入湖底  从后到前

冒泡和选择
冒泡是相邻两个数据比较
选择是一个和剩下所有的比较

- 从左向右扫描数据，选择最大的数据，放在右边。然后扫描第二次，第三次等等。每次都选一个最大的数，就像一个大气泡一样先出来。
- 要点：比较相邻的两个数，如果左边的数大于右边的数就进行交换

效率最低，算法简单。

冒泡排序算法比较简单，只有4行代码。 

如果有几个G数据，那么就比较慢。速度太慢，开发中用的少。

交换次数太多，有不必要的交换，所以慢。

```c++
/// 冒泡排序
/// @param list 数据
/// @param n 数据的个数
void BubbleSort(int list[], int n)
{
    /**
     需要两个循环
     最后剩一个数据的时候，就不需要再循环了。
     例：10个数 需要循环9遍，i < 9  从0到8
     */
    for (int i = 0; i < n - 1; i++) {
        // 里面的扫描 会越来越短，所以会越来越快
        // 10个数 第一遍 扫9次 j从0到8
        for (int j = 0; j < n - i - 1; j++) {
            if (list[j] > list[j + 1]) {
                std::swap(list[j], list[j + 1]);
            }
        }
        
//        //打印每次循环结果
//        for (int k = 0; k < n; k++) {
//            std::cout << list[k] << " ";
//        }
//        std::cout << std::endl;

    }
}
```

```c++
void test()
{
    int a[] = {2,4,6,8,0,1,3,5,7,9};
    BubbleSort(a, 10);
    for (int k = 0; k < 10; k++) {
        std::cout << a[k] << "";
        std::cout << std::endl;
    }
}
```

### 冒泡法优化

算法的时间复杂度还是O(n2)   没有改变。
如果相邻元素之间 都排好序了。

```c++
/// 冒泡法优化，如果已经排好序了，减少排序次数
void BubbleSortBetter(int list[], int n)
{
    bool sortted = false;
    for (int i = 0; (i < n - 1) && (sortted == false); i++) {
        sortted = true;//默认已经排序完毕
        // 里面的扫描 会越来越短，所以会越来越快
        // 10个数 第一遍 扫9次 j从0到8
        for (int j = 0; j < n - i - 1; j++) {
            if (list[j] > list[j + 1]) {
                std::swap(list[j], list[j + 1]);
                sortted = false;//只要发生交换则排序未完成，还需要再排序
            }
        }
        
//        //打印每次循环结果
//        for (int k = 0; k < n; k++) {
//            std::cout << list[k] << " ";
//        }
//        std::cout << std::endl;

    }
}
```

## 选择排序

- 要点：选择排序选最小的，往左边选。
- 想象：一条毛巾    谁最小就把毛巾放它面前 并不交换。可能会经常移动毛巾  但是并不交换数据。扫描完后把毛巾放到最左边。
- 冒泡排序与选择排序
  选择排序比冒泡排序快点
  在冒泡上进行了一定的改进

排序过程：

1. 首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换。
2. 再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第一个记录交换。
3. 重复上述操作，共进行n-1趟排序后，排序结束。

从小到大排序：
选择排序选最小的放最左边
冒泡选最大的放最右边

第一遍是第一小的，第二遍是第二小的，一直循环。

代码算法：

```c++
/// 选择排序
void SelectSort(int *list, const int n)
{
    /**
     需要两个循环
     第一个循环定义扫描的遍数，10个数就扫描10遍
     */
    for (int i = 0; i < n - 1; i++) { //n-1：10个数 扫9遍，最后剩的一个数就不需要扫了。
        int min = i; //min就是毛巾
        // 里面的扫描 扫一遍就排好一个数 所以少扫描一个。
        // 排好的就不需要扫了。所以会越来少。
        for (int j = i + 1; j < n; j++) {
            if (list[j] < list[min]) { // 最小的是毛巾，毛巾min是下标
                // 不交换，只记录下来。如果交换的话就成了冒泡排序了。
                min = j;
            }
        }
        // 扫描一次 结束之后，再交换
        std::swap(list[i], list[min]);
    }
}
```

```c++
void test()
{
    int a[] = {2,4,6,8,0,1,3,5,7,9};
    SelectSort(a, 10);
    for (int k = 0; k < 10; k++) {
        std::cout << a[k] << "";
        std::cout << std::endl;
    }
}
```

选择排序和冒泡排序都是低级排序，因为效率低，速度比较慢。

冒泡经常进行交换，交换次数太多，并且很多交换没有必要的。
选择排序 每次选最小的 在扫描过程中并不交换，到最后才交换。交换少一点。
所以选择排序快点

