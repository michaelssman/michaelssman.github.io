# 单例模式

懒汉式、饿汉式。
懒汉式：
私有一个构造方法 初始化创建 
对静态变量初始化 要放到类的外面。

## 为什么使用单例模式

在应用系统开发中，我们常常有以下需求：

- 在多个线程之间，比如初始化一次socket资源；比如servlet环境，共享同一个资源或者操作同一个对象
- 在整个程序空间使用全局变量，共享资源
- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

因为Singleton模式可以保证为一个类只生成唯一的实例对象，所以这些情况，Singleton模式就派上用场了。

重点：**多线程  加锁   两次判断** 

如何保证一个类只有一个实例：

1. 用一个**私有的静态的数据成员** 创建一个对象  保证只有一个对象。

2. 构造函数做成私有的。

3. 把拷贝构造函数做成私有的，不允许使用。

4. 通过一个共有的方法去使用上面的方法，用指针返回对象（静态的唯一的对象）的地址。

```c++
class Egg
{
    static Egg e;
    int i;
    Egg(int ii):i(ii){}//构造函数做成私有的
	  Egg(const Egg&);//把拷贝构造函数做成私有的，不允许使用	
public:
    static Egg* instance() {return  &e;}
  	int val() const { return  i;}
};

Egg Egg::e(47);

void test777()
{
//    Egg e;
//    Egg e2;
    Egg* e = Egg::instance();
    Egg* e2 = Egg::instance();
  
  	//下面两种其实也是拷贝，所以需要把拷贝构造函数做成私有的，不允许使用。
//  	Egg e3 = *Egg::instance();//获取地址
//    Egg e4(*Egg::instance());//拷贝 复制
}
```

### 注

iOS中`allocWithZone`和`copyWithZone`方法要重写。为防止alloc创建新的对象。

在对象创建的时候，无论是alloc还是new，都会调用到 allocWithZone方法。

在通过拷贝的时候创建对象时，会调用到-(id)copyWithZone:(NSZone **)zone，-(id)mutableCopyWithZone:(NSZone* *)zone方法。

因此，可以重写这些方法，让创建的对象唯一。

```objective-c
static id instance = nil;
+ (instancetype)shareInstance
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

+ (instancetype)allocWithZone:(struct _NSZone *)zone
{
    @synchronized (self) {
        if (instance == nil) {
            instance = [super allocWithZone:zone];
            return instance;
        }
        return instance;
    }
}

- (id)copyWithZone:(NSZone *)zone
{
    @synchronized (self) {
        if (instance == nil) {
            instance = [[SingletonManager allocWithZone:zone]init];
            return instance;
        }
        return instance;
    }
}
```

