# 单例模式

懒汉式、饿汉式。
懒汉式：
私有一个构造方法 初始化创建 
对静态变量初始化 要放到类的外面。

## 为什么使用单例模式

在应用系统开发中，我们常常有以下需求：

- 在多个线程之间，比如初始化一次socket资源；比如servlet环境，共享同一个资源或者操作同一个对象
- 在整个程序空间使用全局变量，共享资源
- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。

因为Singleton模式可以保证为一个类只生成唯一的实例对象，所以这些情况，Singleton模式就派上用场了。

重点：
**多线程  加锁   两次判断** 

C++使用类的**静态成员**进行单例模式设计

只需要一个实例

只有一个文件系统 只有一个窗口管理等等。

如何保证一个类只有一个实例：

首先构造函数做成私有的。

**用一个私有的静态的数据成员 创建一个对象  保证只有一个对象。**

通过一个共有的方法去使用上面的方法，用指针返回对象（静态的唯一的对象）的地址。

```c++
class Egg
{
    static Egg e;
    int i;
    Egg(int ii):i(ii){}
public:
    static Egg* instance() {return  &e;}
};

Egg Egg::e(47);

void test777()
{
//    Egg e;
//    Egg e2;
    Egg* e = Egg::instance();
    Egg* e2 = Egg::instance();
}
```

通过其它的方法还是可以创建新的对象

- 获取地址
- 拷贝 复制

```c++
    Egg e3 = *Egg::instance();
    Egg e4(*Egg::instance());
```

要阻止这两种情况

上面两种都是拷贝构造函数

在类中，把拷贝构造函数做成私有的，不允许使用。

```c++
class Egg
{
private:
    static Egg e;
    int i;
    Egg(int ii):i(ii){}
    Egg(const Egg&);
public:
    static Egg* instance() {return  &e;}
    int val() const { return  i;}
};

Egg Egg::e(47);
```

上面的两个方法就不能使用了。

到此这个类就是一个单例模式。