# 链式栈

链式栈：用链表做的堆栈

做栈有两种方法

1. 数组

   数组是顺序存储 所以用数组做的栈叫顺序栈

2. 链表

   用链表做的堆栈叫链式栈

用链表做的栈比数组在某方面灵活一些。链表做的堆栈，链表动态创建节点，插入数据速度比数组快。

数组容量分配大小确定之后就不改变，当数组容量不够需要重新分配数组。数组做的堆栈有些缺点。用链表做比用数组做的好一点。

### 堆栈特点

先进后出 

### 栈的操作

1. Push（新数据放入堆栈）
2. Pop（把栈顶数据删除）
3. Top（返回栈顶数据，并不删除）

像一个桶一样，放入东西在最上面，拿的时候取最上面的，也就是最后放入的。

两个类

1. 堆栈类
2. 节点类

### 节点：

- 数据域

- 指向下一个节点的指针
- 节点的构造函数

```c++
template<class T> class LinkedStack;//前置声明

//链的节点
template<class T>
class ChainNode
{
    friend class LinkedStack<T>;
private:
    ChainNode(const T&theData, ChainNode *n = 0)
    : data(theData),link(n){}//构造函数
    //私有数据成员
    T data;//数据
    ChainNode<T> *link;//指针指向下一个节点
};
```

#### 链式堆栈：

里面有一个析构函数。析构函数要把里面所有的节点给清除掉。

```c++
//链式栈
template<class T>
class LinkedStack
{
public:
    LinkedStack():top(0){}//构造函数
//    ~LinkedStack(){MakeEmpty();}//析构函数
    bool IsEmpty() const;//堆栈是不是空的
    T& Top() const;//返回栈顶数据
    void Push(const T& e);
    void Pop();
    void MakeEmpty();//把所有数据析构
private:
    ChainNode<T> *top;
};
```

#### IsEmpty：

如果top指向0 那就是空的。

```c++
template<class T>
bool LinkedStack<T>::IsEmpty() const
{
    return top == 0;
}
```

#### Push：

top指针永远指向新放入的数据。

新的节点的指向下一个节点的指针 指向的是以前的top。

```c++
//把数据放进入 新放入的数据永远都是top，top指向新的节点。
template<class T>
void LinkedStack<T>::Push(const T &e)
{
    top = new ChainNode<T>(e,top);
}
```

#### Top:

返回栈顶的数据 

```c++
template<class T>
T& LinkedStack<T>::Top() const
{
    //如果堆栈是空的
    if (this->IsEmpty()) {
        throw "Stack is empty";
    } else {
        return top->data;
    }
}
```

#### Pop:

删除栈顶的数据

1. 用一个指针指向栈顶的节点
2. 栈顶向下移动（栈顶指向栈顶的下一个），栈顶的下一个变成栈顶。
3. 用delete 删除栈顶的节点，没有delete会有内存泄漏。

```c++
//删除栈顶元素
template<class T>
void LinkedStack<T>::Pop()
{
    //如果堆栈是空的
    if (this->IsEmpty()) {
        throw "Stack is empty Cannot delete";
    } else {
        ChainNode<T> *delNode = top;//用一个指针指向栈顶的数据
        top = top->link;//栈顶向下移动
        delete delNode;//删除 防止内存泄漏 和new对应
    }
}
```

##### delete和push中的new节点是对应的。Pop的时候要把它删除。

#### 析构函数：

析构函数要把所有的堆栈里有的节点 都清空删除掉。

一个循环 只要堆栈不是空的 就一直Pop。

```c++
//堆栈节点清空
template<class T>
void LinkedStack<T>::MakeEmpty()
{
    //如果堆栈不是空的。循环删除，直到为空。
    while (!IsEmpty()) {
        Pop();
    }
}
```

做的例子还是模版库。带有析构函数。