# 红黑树成员函数

红黑树最复杂的操作函数是`insert`。在上一个已经完成了。

insert是红黑树最重要的操作，插入节点，插入节点过程中要动态调整 保证红黑树平衡。

对已经做好的红黑树增加一些操作，添加新的成员函数：

- find() 查找 在红黑树中查找某一个数。
- findMin()查找最小的。（最左边的叶子节点就是最小的）
- findMax()查找最大的。（最右边的叶子节点就是最大的）
- isEmpty()判断红黑树是否为空
- makeEmpty()把二叉树置空，清空。



## isEmpty

判断二叉树是不是空树

```c++
bool isEmpty() const;
```

如果是一个空的红黑树，伪根header它的右子节点（真正的根）没有的话，则整个红黑树就不存在了。

```c++
template <class Comparable>
bool RedBlackTree<Comparable>::isEmpty() const
{
    //是否是空的红黑树 判断伪根header右子节点（根）是不是空节点
    return header->right == nullNode;
    //创建的时候就是nullNode 如果等于nullNode就是空的
}
```



## makeEmpty

清空

所有节点清空之后，header的右子要置为空。

```c++
void makeEmpty() const;
```

```c++
//清空
template <class Comparable>
void RedBlackTree<Comparable>::makeEmpty() const
{
    //红黑树里所有的节点删除 节点是insert函数里new创建出来的 按照C++要求就需要delete删除
    //delete删除所有的节点 节点数可能多可能少
    //使用reclaimMemory函数从根节点开始清除
    reclaimMemory(header->right);
    header->right = nullNode;
}
```

私有函数：

makeEmpty中要用，清除节点。

参数t是节点，使用递归设计。

```c++
void reclaimMemory(Node *t) const;//清除节点 清空函数会用到
```



把红黑树所有节点全部删除，节点都是insert中new创建出来的。

把节点全部清除。使用delete。

函数做成通用函数，全部节点如论多少，全部delete。

定义一个函数从根开始清除。从根开始全部清除。

reclaimMemory里面是递归：

左子节点清除，右子节点清除。不断的递归。就可以把所有的清除。

递归必须要有停止条件：如果t== t->left则停止，right也一样。

到了叶子节点停止递归。

```c++
template <class Comparable>
void RedBlackTree<Comparable>::reclaimMemory(Node *t) const
{
    //使用递归设计 所有的子子孙孙清除
    if (t != t->left) {//到叶子节点t == t->left或者t == t->right 停止递归。因为叶子结点的子结点是空的，子结点和子结点也是空的，所以如果都是空的则停止递归。
        reclaimMemory(t->left);//左子节点清除
        reclaimMemory(t->right);//右子节点清除
        delete t;//清除
    }
}
```



## 查找

返回指针还是引用：

找到了可以返回引用，找不到的话 引用不能返回空的。返回指针可以返回空指针。

自己做一个引用类型Cref。Cref也是一个类模版。它可以是一个空引用。不是C++语言的引用，C++语言不允许引用为空。

```c++
//找指定的数
Cref<Comparable> find(const Comparable & x) const;//找的数是x。 如果返回指针（找不到就返回空指针） 如果返回引用（找不到怎么办 C++引用必须引用对象 不能是空的，所以自己做引用类型Cref,Cref也是模版）
Cref<Comparable> findMin() const;//找最小的数
Cref<Comparable> findMax() const;
```



创建一个单独的文件Warpper.h包装类，去定义Cref类。

Cref类内部其实还是指针。只是把指针包装了成了引用。

显式的构造函数 初始化指针。没有参数的构造函数就是传NULL。

再加一个成员函数判断引用是不是空的。 如果指针式空的，则引用就是空的。

可以通过引用去操作数据，如果引用是空的，则抛出一个异常。如果引用不是空的，则返回数据。

把指针包装成了一个类，使用这个类的引用。

```c++
//自定义引用类型
template <class Object>
class Cref
{
public:
    //没有参数的构造函数
    Cref() : obj(NULL) {}//指针传NULL
    //显示的构造函数
    explicit Cref(const Object & x) : obj(&x) {} //初始化
    
    //通过引用操作数据
    const Object & get() const
    {
        if (isNull()) {
            throw NullPointerException(); //抛出异常
        } else {
            //不是空的 返回数据
            return *obj;
        }
    }
    
    //成员函数
    //判断引用是不是空的 如果指针是空的 则引用是空的
    bool isNull() const
    {
        return obj == NULL;
    }
    
private:
    const Object *obj;//指针
};
```



### 异常函数

```c++
class NullPointerException : public DSException
{
public:
    //构造函数 参数是字符串
    NullPointerException(const string & msg = "") : DSException(msg)
    {}
};
```



## findMin

查找红黑树中最小的数

```
findMin() const
```

如果树是空的，则返回一个空引用。

如果不是空的，则从根开始，一直向左查找。然后用引用返回找到的数据。

```c++
//查找最小的
template <class Comparable>
Cref<Comparable> RedBlackTree<Comparable>::findMin() const
{
    //红黑树是不是空的。是空的就返回空引用
    if (isEmpty()) {
        return Cref<Comparable>();
    }
    //不是空的就从根节点一直向左最找最小的，找到最后的时候 左右子都是nullNode
    Node *itr = header->right;
    while (itr->left != nullNode) {
        itr = itr->left;
    }
    return Cref<Comparable>(itr->element);
}
```

## findMax

查找最大的，查找最大的和查找最小的算法一样，只是查找的方向不一样。

找最大的是向右找。

```c++
//查找最大的 向右
template <class Comparable>
Cref<Comparable> RedBlackTree<Comparable>::findMax() const
{
    //红黑树是不是空的。是空的就返回空引用
    if (isEmpty()) {
        return Cref<Comparable>();
    }
    //不是空的就从根节点开始一直向右找右子节点最大的，找到最后的时候 左右子都是nullNode
    Node *itr = header->right;
    while (itr->right != nullNode) {
        itr = itr->right;
    }
    return Cref<Comparable>(itr->element);
}
```

## find

找指定了一个数，从根开始，根据大小一直向左向右查找。

红黑树是一个二叉查找树，所以是一个典型的二叉查找算法。

二叉树的很多算法都可以在红黑树中使用。先序遍历，中序遍历，后序遍历等。

要找的是一个数。使用一个节点保存这个数。

创建一个当前的节点，从根节点开始，根据要找的数和当前节点的数的大小比较判断向左向右的找。

当前节点一直向左向右。如果当前节点不等于nullNode，则找到了，返回。否则就是没找到，返回一个空引用。

```c++
//查找指定的数
template <class Comparable>
Cref<Comparable> RedBlackTree<Comparable>::find(const Comparable &x) const
{
    //要找的数是x
    nullNode->element = x;
    Node *curr = header->right;//节点指针 从根节点开始
    for (; ;) {
        if (x < curr->element) {
            curr = curr->left;
        } else if (x > curr->element) {
            curr = curr->right;
        } else if (curr != nullNode) {
            //找到了
            return Cref<Comparable>(curr->element);
        } else {
            //没找到 返回空引用
            return Cref<Comparable>();
        }
    }
}
```

### 调用测试

```c++
//测试
void test()
{
    const int NEG_INF = -99999;
    RedBlackTree<int> t(NEG_INF);//很大的负数，一个节点都没有 是空的。一个特殊的节点。伪根。
    t.insert(50);
    t.insert(40);
    t.insert(30); //如果这里不是红黑树 就退化成链表的。
    //动态调整 红黑树根动态变化 保证根的左子树右子树深度基本一致 红色节点数一致
    //如果是普通的二叉查找树 根是50 不变
    //红黑树会自动调整平衡

    //根
    cout << t.header->right->element << endl;
    
    //是不是空的
    if (!t.isEmpty()) {
        cout << "红黑树不是空的" << endl;
    }
    
    //清空
    t.makeEmpty();
    if (t.isEmpty()) {
        cout << "红黑树是空的" << endl;
    }
    
    //查找
    Cref<int> r = t.find(66);
    if (r.isNull()) {
        cout << "没找到";
    } else {
        cout << "找到：" << r.get() << endl;
    }
    
    t.insert(200);
    t.insert(100);
    t.insert(90);
    t.insert(50);
    t.insert(80);
    t.insert(70);
    t.insert(60);

    if (t.findMin().get() == 50) {
        cout << "找到了最小的数" << endl;
    }
    cout << "最大的：" << t.findMax().get() << endl;

//    cout << t.header->right->element << endl;
//    cout << t.header->right->right->left->element << endl;
//
//    //向左转
//    t.rotateWithRightChild(t.header->right);
}
```



红黑树的基本操作就都完成了。

还可以添加遍历函数。

还可以给做好的红黑树增加更多算法，加到类里。现在做的只是红黑树基本的函数，最重要的是insert。

