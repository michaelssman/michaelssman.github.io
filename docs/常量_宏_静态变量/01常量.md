# const

const在其他文件使用，C++用的多。

## C和C++

### C语言中

把头文件里的const变成一个声明，`extern const int BUFSIZE;` 	外部常量声明

在源文件里`const int BUFSIZE = 100;`  全部的外部常量

引入头文件，因为替换的时候都是声明，所以就没有问题了。

- 在C语言中默认是外部链接性

  在C语言会出现重复定义	因为C语言const默认外部链接性，**其它文件引用包含const的头文件的时候，预处理 相当于把头文件换成了const的定义 所以会有多处的重复定义**。

  C语言使用const必须写一个源文件，默认外部链接性，extern做一个声明（引用）。

- 不能改变内容的普通变量（常量）

- C语言里 总是分配内存空间

### C++

C++中 不会每次都把引用的头文件替换成对应的常量定义，那样多个文件引入头文件，就会有多处替换，重复 低效率。

#define就是文本替换，const是常量折叠，保存在符号表里，在常量表中去查找替换（如同使用#define一样）。

C++中并没有定义一个常量分配内存，而是做了一个常量折叠。

- 在C++中默认是内部链接性

  但是在C++中可以。因为在C++中const默认的链接性是内部链接性。即使头文件被包含，头文件替换对应的定义，但是是内部链接性，所以不会出错。

  C++可以直接在`.h`头文件使用。

- C++里通常不会分配内存空间，有时会分配内存空间

  1. 使用外部链接性

     在源文件中使用`extern const int BUFSIZE = 100; `这样C++就会给BUFSIZE分配内存。（这是定义）

     在头文件中声明`extern const int BUFSIZE;。` （这是声明）

     这样的就是外部链接性 分配内存。
  
  
    2. 取地址
  
       ![image-20190505164052383](assets/image-20190505164052383.png)
  
  
  3. 用于集合
  
     数组，struct，类
  
     普通的可以放到符号表里，所以不分配内存，而数组值太复杂了，不能放符号表里。

### 分配内存 只有在运行的时候才有值 在编译的时候值是未知的

- `#define` 在预处理的时候。#define会做一个文本查找替换。

  预处理器做的替换，无法检查类型。

- `const` 编译器会把`BUFSIZE` 放到符号表里，没有分配内存。编译的时候都把BUFSIZE换成100。

  编译器做的常量折叠，首先会检查类型。通过安全之后才替换。

### 程序执行四个重要步骤

> 预处理 -> 编译 -> 汇编 -> 链接

![image-20190505161510754](assets/image-20190505161510754.png)

上图在编译的时候

C语言不知道bs值是多少，在运行的时候才知道是100，并且不能改。所以C语言中编译的时候会出错。

但是在C++中可以，并不给bs分配内存，只做常量折叠（查找替换），把bs放符号表里，编译的时候查找，知道bs是100。

## const用于指针

- 指向const常量的指针
- const常量指针
- 赋值和类型检查
  - 可以把非const对象的地址赋值给一个指向const指针
  - 不能把const对象的地址赋值给一个指向非const指针

### 指向const的指针

```c++
const int* u;
```

指针u必须指向常量。

u是变量 是指针 指向`const int`（ 常量整型），是指向常整型的指针。

```c++
const int e = 2;
u = &e;
```

u可以指向常量。

因为u是常量 所以不可以通过指针修改

 `*u = 300`这句是错误的。

u是指针 u指向的是常量 不能被修改。

#### 可以把非const对象的地址赋值给一个指向const指针

```c++
int d = 1;
u = &d;
```

只能使指针u去读取数据 例：输出*u。

不能通过指针修改，例：*u = 300；。

### 定义const指针

```c++
int* const w = &d;
```

w是const指针，常指针，指向整型。

w指向&d，就永远指向&d，不允许修改指向。但是这个数是可以被修改的，*w = 2；

### 常指针 指向常整型

```c++
const int e = 100;

const int* const x = &e;
```

x常指针 指向常整型

```c++
int d = 1;
const int* const x2 = &d;
```

下面这两种写法一样：const都在`*`左边

const都是修饰int整型，指针指向const整型。

```c++
const int*u;
int const*v;
```

第二种：const在*右边

const用来修饰指针，const指针。

```c++
int* const w = &d;
```

下面的e是const 但是指针n不是const，所以赋值错误。

```c++
const int e = 100;
int* n = &e;		//（这种错误）
```

可以把非const赋值非const，const指针保证不会对它修改。即使它可以修改，也不修改。这是安全的。

e是const，把它赋值给非const。通过指针可以对它修改，不是安全的。所以通不过。但是可以做一个强制转换：

```
int *k = (int *)&e;
```

默认不行，但是强制了也可以这样做，只是很危险。尽量不要这样转换。不能修改，只能读取。

```
*k = 111; //错误的
cout << *k << endl;	//可以
```

- 一个不能修改值。

  非常指针const int*u

- 一个不能修改指针指向。

  常指针int* const w

### 总结

const修饰什么，什么就不可以修改。

```c++
int* const w = &d;//w就不可以修改
const int* u;//*u就不可以修改
```

### 字符串

```c++
const char* cp = "howdy";
```

应该有const。

C语言早期是下面这种：

```c
char* cp = "howdy";
```

这种有问题。

cp不能被修改。

```
cp[2] = 'a'	//错误
*(cp + 2) = 'a'	//错误
```

如果要修改 就要用字符数组

```
char cp2[] = "howdy";

cp2[2] = 'a';
```

















