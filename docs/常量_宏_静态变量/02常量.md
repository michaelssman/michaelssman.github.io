# 常量-把const用于指针

- 指向const的指针（指向常量的指针）
- const指针（常量指针）
- 赋值和类型检查
  - 可以把非const对象的地址赋值给一个指向const指针
  - 不能把const对象的地址赋值给一个指向非const指针



### 指向const的指针

```c++
const int* u;
```

指针u必须指向常量。

u是变量 是指针 指向`const int`（ 常量整型），是指向常整型的指针。

```c++
const int e = 2;
u = &e;
```



u可以指向常量。

因为u是常量 所以不可以通过指针修改

 `*u = 300`这句是错误的。

u是指针 u指向的是常量 不能被修改。

#### 可以把非const对象的地址赋值给一个指向const指针

```c++
int d = 1;
u = &d;
```

只能使指针u去读取数据 例：输出*u。

不能通过指针修改，例：*u = 300；。

### 定义const指针

```c++
int* const w = &d;
```

w是const指针，常指针，指向整型。

w指向&d，就永远指向&d，不允许修改指向。但是这个数是可以被修改的，*w = 2；



### 常指针 指向常整型

```c++
const int e = 100;

const int* const x = &e;
```

x常指针 指向常整型

```c++
int d = 1;
const int* const x2 = &d;
```



下面这两种写法一样：const都在`*`左边

const都是修饰int整型，指针指向const整型。

```c++
const int*u;
int const*v;
```

第二种：const在*右边

const用来修饰指针，const指针。

```c++
int* const w = &d;
```



下面的e是const 但是指针n不是const，所以赋值错误。

```c++
const int e = 100;
int* n = &e;		//（这种错误）
```

可以把非const赋值非const，const指针保证不会对它修改。即使它可以修改，也不修改。这是安全的。

e是const，把它赋值给非const。通过指针可以对它修改，不是安全的。所以通不过。但是可以做一个强制转换：

```
int *k = (int *)&e;
```

默认不行，但是强制了也可以这样做，只是很危险。尽量不要这样转换。不能修改，只能读取。

```
*k = 111; //错误的
cout << *k << endl;	//可以
```



- 一个不能修改值。

  非常指针const int*u

- 一个不能修改指针指向。

  常指针int* const w

### 总结

const修饰什么，什么就不可以修改。

```c++
int* const w = &d;//w就不可以修改
const int* u;//*u就不可以修改
```



# 字符串

```c++
const char* cp = "howdy";
```

应该有const。

C语言早期是下面这种：

```
char* cp = "howdy";
```

这种有问题。

cp不能被修改。

```
cp[2] = 'a'	//错误
*(cp + 2) = 'a'	//错误
```

如果要修改 就要用字符数组

```
char cp2[] = "howdy";

cp2[2] = 'a';
```



