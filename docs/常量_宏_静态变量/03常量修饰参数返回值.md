# 常量 — 函数参数和返回值

- 传递const值
- 返回const值
- 临时量
- 传递和返回地址

## 函数参数值

传参数 参数也可以是指针（引用也可以）

1. 传普通参数
2. 利用指针方式传参数 
3. 利用引用方式传参数

参数传递的过程中 可以加上const

实际根据需要来确定要不要加const。

```c++
void f4(const int i)
{
}

void f5(const int* pi)
{
}

void f6(const int& ri)
{
}
```

1. 普通传递

   按值传递 

   传递的是拷贝 改的是拷贝复制品。不是原来的数据并没有改变本身 所以是不会变的

   如果传递的参数是一个很大的参数class。函数传递参数class。传递的是复制 复制多占用内存 复制需要时间，效率不高。 

   传比较大的对象，可以传指针，也可以传引用。

   地址复制了一份。地址没那么大，速度会快。

2. 利用传指针的方式

   参数可以很大可以很小，都没关系。传的是指针。

   可以通过指针对原来的数据进行修改。因为有地址，所以可以对原来的数据进行修改。

3. 引用和指针完全一样

   也会发生修改。

   指针和引用都是地址

#### 两种情况用指针和引用

1. 想对原始数据进行修改。
2. 参数数据对象很大（clase，数组） 用指针。速度快。

指针引用或者普通传参都可以加const

##### 一个参数有const和没有const的不同：

- 有const 传进来的参数不允许在内部修改。传递进来的数据不许被修改。加了const 就加了保护。

- 没有const 传进来的参数可以修改。

## 函数返回值

返回C++内置类型（int）自己写的类型（class）

返回指针

返回引用。

```c++
int g1()
{
    return 1;
}

int* g2(int* x)
{
    (*x)++;
    return x;
}

int& g3(int& x)
{
    x++;
    return x;
}
```

这三个函数 前面都可以加const

加const的不可以被修改，不加const的可以被修改。

- 函数返回值

  函数内部的这个返回值是局部的 函数结束之后就没了。返回之后就没了。外面接收的也是一个复制品，和函数普通参数传递一样。按值传递。

- 返回指针

  复制的是地址，得到地址的复制，对原来的数据进行操作修改。

  不想修改则加上const。

- 引用
  同理。和地址一样。可以修改，不想修改则可以加上const。

需要对返回的数据进行保护就加上const。

```c++
void u(const int* cip)
{
    //*cip = 2;//不可以
    int i = *cip;//可以
    //int* ip2 = cip;//不可以
}
```

返回值是一个指向const整型的const指针

```c++
const int* const w()
{
    static int i;
    return &i;
}
```

这两种接收都可以，只要第一个是const就行。

```c++
const int* const ccip = w();
const int* cip2 = w();
```

- 非const可以赋值给一个const。
- const不能赋值给一个非const。

总结：

这都是一种保护措施。

参数：

普通的那种很少传const，本身就是复制品，不怎么需要。

多数传指针 传引用都是用const。指针和引用可以修改数据 不允许的就需要加const。