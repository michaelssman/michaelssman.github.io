# token

## token无感刷新

意义：单点登录要用到。

登录成功之后，服务器会返回一个响应结果（token），客户端去保存这个token，一般是local storage或者user default。每次重新登陆都会给一个token。

后续请求（受保护的接口）的时候会在请求头把这个token给带上，服务器验证token是有效的，就会响应一个正确的结果。

服务器响应401没有权限，原因是token的过期时间非常的短，只有几十分钟。

服务器除了会返回一个过期时间非常短的token，还有一个过期时间比较长Rrefreshtoken，过期时间一般几天或者几个月。客户端也要保存这个refreshtoken。

token过期的话就可以拿这个过期时间长的refreshtoken去重新换，调用刷新token的网络请求。同样的客户端去保存token。

### 实现无感刷新

在响应里面去判断，如果是token过期无权限的原因拿不到数据，一般是响应的code是401。则调用刷新token方法（异步的），因为是异步的，所以要等待刷新完成之后，再重新请求该网络请求。该网络请求要改请求头里面的Authorization，token要换成新的token，**否则会进入死循环**，还是无权限。

#### refreshtoken也过期的情况

如果还是调用刷新token方法，则会一直报401无权限，无穷尽。在调用刷新token方法的时候header里面加上isRefreshToken: true。如果是刷新token的请求，则不走普通请求保护的接口逻辑。

#### 如果不是刷新token的方法，并且报401无权限

则请求是刷新token的请求

- 如果刷新到了token`isSuccess=true`则可以再重新请求该网络请求。
- 如果没刷新到`isSuccess=false`则退出登录需要重新登录（真的无权限了）。

#### 刷新token的过程比较长的情况，期间又有多个其它的保护接口的请求

有一个请求正在刷新token当中，这个时候又来了1000个请求，因为之前的刷新token还没完成，而这1000个请求都没有权限，它们也得刷新token，可能造成冗余的刷新请求。1000个请求不用去刷新，等第一个刷新token结束，1000个请求都能拿到token了。

把刷新token做唯一化。可以用一个变量去标识是否已经从存在刷新token的请求。

- 如果已经有在刷新token的请求了，就返回，不要再新增刷新token。所有的刷新token请求都是同一个。
- 没有刷新token的请求时，则创建一个刷新token的请求。