# 模版语法

```c++
template <class T>
class X {
  ...
};
```

重要的是`template`关键字。

### 例：

数组

C++数组不检查越界。

自己写一个class，把数组封装起来，检查不允许越界。

```c++
class Array
{
    enum {size = 10};
    int A[size];
public:
    int& operator[](int index)//index 下标，要检查是否越界  内联的函数
    {
        //对下标进行检查，下标大于等于0，小于size
        return A[index];//如果没有越界，就返回数组里的数据。
    }
};
//调试
void test() {
    Array b;
    std::cout << b[8] <<std::endl;//没越界
    std::cout << b[10] <<std::endl;//越界，会检查，然后处理
}
```

这样封装的就比C++的好一些。

但是C++类型非常多，整型，浮点型，等等。要针对每一个类型做一个数组class。比较繁琐，写很多class。代码都是重复的。

可以使用继承，但是继承会比较复杂。简单的问题复杂化了。比较好的解决办法就是模版。

### 模版：类模版

```c++
//这是一个模版，模版不是一个真正的类，使用模版进行实例化，C++会创建一个类出来。
template<class T>//T是模版的替换参数，代表一个类型
class Array
{
    enum {size = 10};//枚举常量
    T A[size];
public:
    T& operator[](int index);//重载下标运算符。index：下标。要检查是否越界
//    {
//        //对下标进行检查，下标大于等于0，小于size
//        return A[index];//如果没有越界，就返回数组里的数据。
//    }
};

//函数写到类外面，比较复杂，还要写`template<class T>` 和`Array<T>::`，写到类里面是内联函数比较简单。
template<class T>
T& Array<T>::operator[](int index)//重载下标运算符。index：下标。要检查是否越界
{
    //对下标进行检查，下标大于等于0，小于size
    return A[index];//如果没有越界，就返回数组里的数据。
}

//调试
void test() {
    Array<int> ia;//当这样写的时候，C++会帮我们从上面的模版，用int把所有的T换掉。
    Array<float> fa;
    //根据需要 C++会帮我们创建不同的类。非常灵活。
    
    for (int i = 0; i < 10; i++) {
        ia[i] = i * i;
        fa[i] = float(i) * 1.414;
    }
    for (int j = 0; j<10; j++) {
        std::cout << j << ":" << ia[j] << ", " << fa[j] <<std::endl;
    }
}
```



类模版和普通的类是不一样的，做模版的时候，代码都得放到头文件中，不能在源文件。C++编译的时候会生成类，所以必须是可见的。否则没有办法编译。