# 模版中的常量

模版的参数中可以使用C++内置类型（常量）。还可以设置默认值。

size是不可以修改的。

模版变成类的时候C++会把`int size = 10`变成常量，所以是不能修改的。

```c++
template<class T, int size = 100>//模版常量size
class Array
{
		//enum {size = 10};//枚举常量
    T A[size];
public:
    ...
};
```

```c++
template<class T, int size = 10>
class Array
{
    //enum {size = 10};//枚举常量
    T array[size];
public:
    T& operator[](int index);//重载下标运算符。index：下标。要检查是否越界
    int length() const { return size; }//成员函数，返回长度。
};

template<class T, int size>//这里不用谢size = 1
T& Array<T, size>::operator[](int index)//重载下标运算符。index：下标。要检查是否越界
{
    //对下标进行检查，下标大于等于0，小于size
    return array[index];//如果没有越界，就返回数组里的数据。
}

//再做一个Number类 封装float
class Number
{
    float f;
public:
    //类型转换，float转为Number
    Number(float ff = 0.0f) : f(ff) {}//构造函数，做类型转换用的
    Number& operator=(const Number& x)//赋值运算符重载
    {
        f = x.f;
        return *this;
    }
    //Number转float
    operator float() const {return f;}
    //有元函数 用来输出，也是用运算符重载 流输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const Number& x)
    {
        return os << x.f;
    }
};

//测试
void test() {
    Array<int, 100> ia; //第二个参数，如果不写size就是默认的10，写了就是写的值100，可以重新定义.
    Array<Number, 50> a;
    Number n = 1.23;
    std::cout << n <<std::endl;//输出运算符 使用运算符重载
    
    float f = n;//Number变成float
    std::cout << f <<std::endl;//输出运算符 使用运算符重载

}
```

例二：

再做一个模版

```c++
//创建一个容器Holder类
template<class T, int size = 20>
class Holder
{
    Array<T,size>* np;//数组 指针指向数组
public:
//    Holder()
//    {
//        np = new Array<T, size>;//在构造函数中初始化数组，这是其中的一种方法
//    }
    Holder():np(0){}
    T& operator[](int i)//重载下标运算符。index：下标。
    {
        //第一次使用的时候，初始化数组，使用这种方法比较好
        if (!np)  new Array<T, size>;
        return np->operator[](i); //调用数组ARRAY的运算符重载
    }
    int length() const { return size; }//成员函数，返回长度。
    ~Holder() {delete np;}
};
```

```c++
//测试
void test() {
    Holder<Number> h;//调用构造函数创建对象，这时候数组还没有创建。
    for (int i = 0; i<20; i++) {
        h[i] = i * 10;
    }
    //数组中的元素 显示出来
    for (int j = 0; j < 20; j++) {
        std::cout << h[j] <<std::endl;
    }
}
```









