# 带内联函数的Stash和Stack

- Stash
- Stack
- 减少混乱 - 内联函数编程指南



Stash和Stack成员函数做成内联函数，加快速度，小的函数。



在头文件中，可以使用inline单独写函数实现，也可以在类里面直接写。不需要inline修饰。

构造函数中可以使用初始化列表，更加方便。因为本身就是初始化的。



Stack中的方法都是小方法，所以可以都写成内联函数，都在.h文件中。不需要源文件。



有了内联函数 Stash和Stack会更有效率。运行速度会更快。

- 把比较小的函数变成内联函数。比较大的不能变。
- 内联函数一定要放到头文件里



构造函数做成内联的。不能在.cpp中 应该在.h文件。

两种方法：

1. .h头文件中 

2. .h头文件定义中 直接定义

初始化列表：

因为构造方法里面的代码都是初始化，所以可以使用初始化列表。

析构函数也做成内联函数。

```c++
// C++的Stash
class Stash
{
private:
    int size;// 每一个是多大。存字符串的话就是最多的存多少字符。
    int quantity;// 数量。一共可以保存多少个。
    int next;// 已经保存了多少个。
    unsigned char* storage;// 指针
    
public:
    //构造函数。对成员进行初始化 使用初始化列表
    //在类里面。现在就是内联的 不需要inline。
    Stash(int sz, int initQuantity = 0) : size(sz),quantity(0),storage(0)
    {
        inflate(initQuantity);
    }
    int add(const void* element);
    // 扩大内存
    void inflate(int increase);
    int count()
    {
        return next;
    }
    void* fetch(int index)
    {
        assert(0 <= index);
        if (index >= next) {
            return 0;
        }
        return &(storage[index * size]);
    }
    ~Stash()//析构函数 做成内联的
    {
        if (storage != 0) {
            delete [] storage;
        }
    }
};
```

## 在头文件中。比较小的函数做成内联的。

add和inflate函数比较大，就不做内联的。

count和fetch比较小，做成内联的。

```c++
inline int Stash::count()
{
    return next;
}

inline void* Stash::fetch(int index)
{
    assert(0 <= index);//要包含C++头文件#include <cassert>
    if (index >= next) {
        return 0;
    }
    return &(storage[index * size]);
}
```

内联函数一定要在.h文件里。

也可以写到类的内部。

# 减少混乱 - 内联函数编程指南

内联函数写法不统一，不同的人写的不一样，为了统一做的编程指南。

写成这样的比较好。

```c++
class Rectangle
{
    int width, height;
public:
    //构造函数
    Rectangle(int w = 0, int h = 0);
    int getWidth() const;
    void setWidth(int w);
    int getHeight() const;
    void setHeight(int h);
};

inline Rectangle::Rectangle(int w, int h) : width(w), height(h) {}
inline int Rectangle::getWidth() const
{
    return width;
}
inline void Rectangle::setWidth(int w)
{
    width = w;
}
inline int Rectangle::getHeight() const
{
    return height;
}
inline void Rectangle::setHeight(int h)
{
    height = h;
}
```

内联函数写在类的定义外面。

优点：

想要内联的时候就加上inline 不想的时候就把inline去掉。方便。

内联如果写在类的里面，不想做成内联了 还得从里面复制出来。麻烦。所以写在外面。

测试：

运行代码 测试是否正确。

```c++
//测试
void test()
{
    Rectangle r(19, 47);
    int iHeight = r.getHeight();
    cout << iHeight << endl;
    r.setWidth(100);
    r.setHeight(r.getWidth());
    cout << r.getWidth() << endl
    << r.getHeight() << endl;
}
```

