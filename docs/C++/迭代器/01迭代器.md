# 迭代器

迭代器是一种常见的设计方法。

迭代器一般情况下都是和容器联合一起使用的，容器就是数据结构，各种数据结构（堆栈，树），可以通过迭代器把容器里的数据一个一个的读取，迭代器提供了一种方便的方法接口。一个不落的读取。

迭代器是读取查看，并不会改变堆栈里的数据。堆栈里的数据没有发生任何改变。

迭代器一般都是只读的。并不会删除修改。

堆栈没有迭代器的话，想要查看数据不删除的话就没有办法，因为pop会删除，peak只能查看最上面的。就只能使用迭代器。

一般都会为容器做一个迭代器。做迭代器也很简单，代码也不多。更好的迭代器代码多一些，功能强一些。

#### 代码：

```c++
//做一个简单的堆栈
//整型堆栈
class IntStack
{
    enum { ssize = 100};//容量100
    int stack[ssize];//内部是一个数据
    int top;//栈顶（下标）
public:
    IntStack() : top(0) {}//栈顶设置为0
    void push(int i)//数据压入堆栈
    {
        //如果堆栈满了，就不做执行
        stack[top++] = i;
    }
    int pop()//从堆栈取数据
    {
        //堆栈不能是空的，空的就取不了
        return stack[--top]; //top没有数据，所以需要--
    }
    //迭代器要操作堆栈里面的数据
    //要做成友元类
    friend class IntStackIter;
};
//堆栈的迭代器
//迭代器要做的像灵巧指针 使用迭代器的时候像一个指针 可以++ ++是对index进行的操作，索引的操作又是对堆栈内部的数组的操作，数组也是用下标进行操作的。
class IntStackIter
{
    //迭代器要操作堆栈里面的数据
    //要做成友元类
    //迭代器对堆栈进行操作，通过构造函数把堆栈传递进来。
    IntStack& s;
    //索引 迭代器使用的
    int index;
public:
    //通过构造函数把堆栈传递进来，通过迭代器内部的s保存
    IntStackIter(IntStack& is) : s(is), index(0) {}
    //运算符重载。因为指针有++
    //迭代器++的时候，都会从容器中读一个数据出来。迭代器像一个指针，++就会读取下一个数据。
    //前++
    int operator++()
    {
        //容器里没有数据，就不能读了。
        return s.stack[++index];//从堆栈内部的数组里取数据出来。数据都是保存在数组里的。
    }
    //后++
    int operator++(int)
    {
        //容器里没有数据，就不能读了。
        return s.stack[index++];
    }
};
```

### 调试：

```c++
//测试
void test() {
    IntStack s;
    s.push(10);
    s.push(20);
    s.push(30);
    s.push(40);
    s.push(50);
    s.push(60);

    //使用迭代器 读取数据
    IntStackIter it(s);//把堆栈传给迭代器
    for (int i = 0; i < 6; i++) {
        std::cout << it++ << std::endl;
    }
    
    //不用迭代器也可以读取，但是pop是把数据都删除了。
    //迭代器是读取查看，并不会改变堆栈里的数据。堆栈里的数据没有发生任何改变。
    //迭代器一般都是只读的。并不会删除修改。
    //堆栈没有迭代器的话，想要查看数据不删除的话就没有办法，因为pop回删除，peak只能查看最上面的。就只能使用迭代器。
    for (int i = 0; i < 6; i++) {
        std::cout << s.pop() << std::endl;
    }
    
}
```



