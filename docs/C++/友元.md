# 友元friend

例子：如果是朋友的话 就可以访问我们家，来吃饭，来玩。如果不是我们的朋友则不可以。

友元可以使用私有的函数和变量

想要访问私有函数或变量 需要使用友元

- 全局函数    -->友元
- 成员函数    -->友元
- 结构，类    -->友元

都可以作为友元

类（结构）的成员函数可以类（结构）使用私有变量

前置声明可以省略 不写。

作为参数也可以访问私有变量

不是友元不能对私有的数据进行操作。

可以把整个结构设置为友元

```c++
struct X; //声明

struct Y
{
    void f();
    void e(X*);
};

//void h();//声明
struct X
{
private:
    int i; //私有
public:
    void initialize();//共有
    friend void Y::f(); //友元
    friend void Y::e(X *); //友元
//    friend void Z::m(X *);
    friend struct Z;//如果Z里很多函数都需要访问X的私有成员，把整个结构Z设置为友元
    friend void g(X*, int); //友元
    friend void h(); //友元
};

void X::initialize()
{
    i = 0;
}

struct Z
{
private:
    int i;
public:
    void initialize();
    void m(X* x);
};
void Z::m(X *x)
{
    x->i = 11;
    cout << x->i << endl;
}

void Y::f()
{
    X x;
    x.i = 99;
    cout << x.i << endl;
}
void Y::e(X *x)
{
    x->i = 88;
    cout << x->i << endl;
}

//也可以用参数的形式传递，声明为友元就可以访问i
void g(X* x, int i)
{
    x->i = i;
}

void h() //h想要使用X的i 必须是X的友元
{
    cout << "hello h" << endl;
    X x;
    x.i = 12;
    g(&x, 100);
    cout << x.i << endl;
}

void test()
{
    h();
}
```

例

两个结构

使用Pointer操作Holder的a数组。

```c++
const int sz = 20;//常量数组大小
struct Pointer;
struct Holder
{
private:
    int a[sz];//私有数组
public:
    void initialize();
    friend struct Pointer;
};

struct Pointer
{
private:
    Holder* h;
    int* p;
public:
    void initialize(Holder* h);
    void next();
    void previous();
    void top();
    void end();
    int read();//读取
    void set(int i);
};

void Holder::initialize()
{
    memset(a, 0, sz*sizeof(int));
}
void Pointer::initialize(Holder *rv)
{
    h = rv;
    p = rv->a;//指针指向数组a
}
//指向下一个
void Pointer::next()
{
    if (p < &h->a[sz - 1]) {
        p++;
    }
}
//前一个
void Pointer::previous()
{
    if (p > &h->a[0]) {
        p--;
    }
}
//第一个
void Pointer::top()
{
    p = &(h->a[0]);
}
//最后一个
void Pointer::end()
{
    p = &(h->a[sz-1]);
}
int Pointer::read()
{
    return *p;
}
//修改指针指向的数
void Pointer::set(int i)
{
    *p = i;
}
```

调用

```c++
void test()
{
    Holder h;
    Pointer hp;
    
    h.initialize();
    hp.initialize(&h);
    
    for (int i = 0; i<sz; i++) {
        hp.set(i);
        hp.next();
    }
    
    //把指针调整到第一个
    for (int i = 0; i<sz; i++) {
        cout << "hp = " << hp.read() << endl;
        hp.next();
     }
}
```

嵌套 结构很大
可以做很多结构 利用友元，有很多结构的时候，使用友元。

对象小一些  可以多一些
多个对象的时候 可以利用友元friend

嵌套的话就不用友元了，但是嵌套可能会使结构或类变得很大。

不嵌套的话就需要使用友元才能访问。