![图片发自简书App](http://upload-images.jianshu.io/upload_images/1892989-2044e85ec032f8ba.jpg)

二叉树。叶子结点是数字。对这个二叉树进行中序遍历 生成中缀表达式，进行后序遍历 生成后缀表达式。

两大块儿：
1. 二叉树的几个性质
2. 二叉树的几种存储
    几种表示方法


树是递归加线性表。 

树的存储：
1. 把每一个结点信息 存入数据库
2. 把树和树之间的关系存入数据库
存   复原难
所以要转成二叉树。

不转二叉树的存法：

1. 节点表

2. 节点关系表

   ![树如何在db中存储](https://upload-images.jianshu.io/upload_images/1892989-41488a9aa3c21531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

满二叉树
完全二叉树
为何要研究这两种特殊形式？
因为它们在顺序存储方式下可以复原！

## 树的顺序存储  

借助下标。
对完全二叉树，若从上至下，从左至右编号，则编号为`i`的结点，其左孩子编号必为`2i`，其右孩子编号必为`2i+1`；其双亲的编号必为`i/2`（`i=1时为根，除外`）。

## 树的链式存储  

### 树的表示法
#### 二叉链表示法

```c++
/**
//二叉树的二叉链表存储表示
typedef  struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;//左右孩子指针
}BiTNode, *BiTree;
 */

//等于下面
struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;//左右孩子指针
};
typedef struct BiTNode BiTNode;
typedef struct BiTNode* BiTree;
```

指针指向谁 就把谁的地址赋给指针
![image.png](https://upload-images.jianshu.io/upload_images/1892989-ba087db4a91d19ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![通过指针方式 建立树](https://upload-images.jianshu.io/upload_images/1892989-40f11a85e02ac883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 三叉链表示法：

data lchild rchild parent

#### 双亲链表

![image.png](https://upload-images.jianshu.io/upload_images/1892989-5f6752d67a12efa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在子结点里面保存了双亲的位置信息

- 结点：
`data`  值
`parentPosition`  父结点位置
`LRTag`  是左孩子还是右孩子
- 树：
  1. 一个结点数组 （树也是集合，把结点存储到数组中，（给结点编号，数组下标））
  2. 结点数目
  3. 根结点位置
  ![image.png](https://upload-images.jianshu.io/upload_images/1892989-de5cefe03325e66c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

相当于两个表：

1. 结点表
2. 关系表

双亲链表示法 示例：
![image.png](https://upload-images.jianshu.io/upload_images/1892989-59cdf005e484f487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 线索表示法

树在db中存储：
![image.png](https://upload-images.jianshu.io/upload_images/1892989-c91d3d65fdf2a0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注：
需要memset
memset：指针指向的内存空间如果是空结点 指向NULL。

树和图
需要定义好数据结构，即定义结构体。

## 树的遍历
先（根）序遍历，  中（根）序遍历，  后（根）序遍历

遍历算法 用递归

经过的路径是一样的  访问结点的时机不同。

![image.png](https://upload-images.jianshu.io/upload_images/1892989-d0a2cc8977106c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 树的非递归遍历
先序和中序遍历用到栈，（先进后出）弹栈顶。后序遍历用队列 。

非递归遍历 中序遍历的几种情况

1. 什么时候访问根，什么时候访问左子树，什么时候访问右子树

   当左子树为空或者左子树已经访问完毕以后，再访问根

   访问完毕根以后，再访问右子树

2. 为什么是栈，而不是其他（比如说是队列）

   先走到的后访问，后走到的先访问，显然是栈结构

3. **结点所有路径情况**

   步骤1:

   如果结点有左子树，该结点入栈

   如果结点没有左子树，访问该结点

   步骤2:

   如果结点有右子树，重复步骤1

   如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1

   如果栈为空，表示遍历结束

注意：入栈的结束表示，本身没有被访问过，同时右子树也没有被访问过。

#### 代码实现思想：

一直往左走，找到中序遍历的起点，打印中序遍历的起点。（判断是否有左子树，有就一直往左走，入栈）

如果起点结点有右子树，重复上一步骤。

如果结点没有右子树，栈非空，栈顶元素回退。

如果没有右子树，栈为空，则结束。

##  树的基本操作
### 1、求叶子结点的数目

思路：用任何一种遍历算法，凡是左右指针均空者，则为叶子，将其统计并打印出来。

```c++
int sum;
void countLeaf(BiTNode *T)
{
    if (T != NULL) {
        if (T->lchild == NULL && T->rchild == NULL) {
            sum ++;
        }
        if (T->lchild) {
            countLeaf(T->lchild);
        }
        if (T->rchild) {
            countLeaf(T->rchild);
        }
    }
}
//上面方法在多线程中 会对sum资源争夺。
void countLeaf3(BiTNode *T, int *sum)
{
    if (T != NULL) {
        if (T->lchild == NULL && T->rchild == NULL) {
            (*sum) ++;
        }
        if (T->lchild) {
            countLeaf3(T->lchild, sum);
        }
        if (T->rchild) {
            countLeaf3(T->rchild, sum);
        }
    }
}
```

### 2、copy二叉树

一个结点一个结点的拷贝。拷贝根结点 拷贝左子树 拷贝右子树。
如果只有一个结点，则拷贝这个结点，左右孩子指向NULL。如果有左子树，拷贝左子树根，判断左子树的根是否有左右孩子，递归循环这种操作。
拷贝也得malloc内存。

### 3、求树的深度（高度）

求左子树的高度  求右子树的高度 哪个大取哪一个 最后再加1 （根）
左子树也是这样求，右子树也是这样求。

```c++
int Depth(BiTNode *T)
{
    int deptleft = 0;
    int deptright = 0;
    int deptval = 0;
    if (T == NULL) {
        deptval = 0;
        return deptval;
    }
    //左子树高度
    deptleft = Depth(T->lchild);
    //右子树高度
    deptright = Depth(T->rchild);
    
    //+1
    deptval = 1 + (deptleft > deptright ? deptleft : deptright);
    return deptval;
}
```

#### 创建树
1. `#`建树
后面有两个`井`号的 一定是叶子结点。
左子树什么时候结束是能通过`井井`判断出来的
![image.png](https://upload-images.jianshu.io/upload_images/1892989-02dd15203d12a073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

先序遍历的  先是根 然后一路左子树  遇到`井`则这个左子树到最后一个 最后一个的右子树 遇到`井井` 则向上退 递归后退着处理 建立父结点的右子树。

创建树的时候用先序创建 
销毁树的时候用后序销毁树
![image.png](https://upload-images.jianshu.io/upload_images/1892989-e1b9d194fb9f657c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
不能先把根给释放了  还得缓存

2. 中序、先序
> 算法:
> 1. 通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树
> 2. 在A的左子树中，找左子树的根结点（在先序中找），转步骤1
> 3. 在A的右子树中，找右子树的根结点（在先序中找），转步骤1

>讲解:
>先序遍历结果：ADEBCF
>中序遍历结果：DEACFB

先序遍历可以找到根 中序遍历可以找到是左子树还是右子树。

方法就是先先序找到根结点再中序找到左右子树 再先序 再中序 一直循环。

3. 中缀和后缀建树

要唯一
- 通过中序遍历和先序遍历可以确定一个树
- 通过中序遍历和后序遍历可以确定一个树
通过先序遍历和后序遍历确定不了一个树。
单独先序遍历，能求解根，但不能求解左子树和右子树的结束、开始分界线。

#### 树的线索化
##### 概念

普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得。
若可将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜” 而遍历整个树了。

##### 二叉线索树思想是干什么的？

希望能像链表那样遍历一棵树。

修改链表之间的关系 让叶子结点 
结点添加两个域

判断是线索化的域还是左孩子（右孩子）的域
![image.png](https://upload-images.jianshu.io/upload_images/1892989-813c761898bb20c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

结点的空余指针域 左孩子指向前驱 右孩子指向后继

>如何进行二叉树的线索化：
>由于线索化的实质是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到。因此线索化的过程即为在遍历的过程中修改空指针的过程。为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，若指针p指向当前访问的结点，则pre指向它的前驱。

因此可得中序遍历建立中序线索化链表的算法如下所示：
![image.png](https://upload-images.jianshu.io/upload_images/1892989-7782c3e5c13e8587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![核心代码.png](https://upload-images.jianshu.io/upload_images/1892989-09d4cb1548fe57bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

让当前指针的左孩子 指向pre结点
让pre结点的右孩子 指向后继p

![image.png](https://upload-images.jianshu.io/upload_images/1892989-cdbd97d1ab690890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/1892989-57f0aafd799925d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###### 遍历二叉线索树
![image.png](https://upload-images.jianshu.io/upload_images/1892989-8950a254722ccb9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们做的时候
访问的时候 放到链表里面就可以了，不用按照上面那种复杂的。

#### 最优二叉树（霍夫曼树）
树的带权路径长度
例：
组建一个网络，耗费最小 WPL最小。

- 霍夫曼树是一种特殊的二叉树
- 霍夫曼树应用于信息编码和数据压缩领域
- 霍夫曼树是现代压缩算法的基础

思想：
树是链表和递归组成的